<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Evo Lite v5.5</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Hiragino Kaku Gothic ProN', sans-serif; user-select: none; touch-action: none; -webkit-touch-callout: none; transition: filter 2s; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        /* UI Layers */
        #stats-list { 
            position: absolute; 
            top: 80px; 
            left: 20px; 
            text-align: left; 
            color: rgba(255,255,255,0.7); 
            font-size: 11px; 
            line-height: 1.5; 
            text-shadow: 1px 1px 2px #000; 
            pointer-events: none; 
            font-family: monospace; /* 数値を揃えるため等幅フォント */
        }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #top-bar { position: absolute; top: 15px; left: 50%; transform: translateX(-50%); text-align: center; color: white; text-shadow: 0 2px 4px rgba(0,0,0,0.8); width: 80%; max-width: 600px; }
        #xp-bg { width: 100%; height: 12px; background: #222; margin-top: 8px; border: 1px solid #555; border-radius: 6px; overflow: hidden; box-shadow: 0 0 10px rgba(0,0,0,0.5);}
        #xp-fill { width: 0%; height: 100%; background: linear-gradient(90deg, #00ffff, #0088ff); transition: width 0.1s; }
        #skill-list { position: absolute; top: 60px; right: 20px; text-align: right; color: rgba(255,255,255,0.8); font-size: 11px; line-height: 1.4; text-shadow: 1px 1px 2px #000; pointer-events: none; }
        
        #hp-container { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); width: 300px; text-align: center; color: white; font-weight: bold; pointer-events: none; }
        #hp-bar-bg { width: 100%; height: 16px; background: #330000; border: 2px solid #555; border-radius: 8px; overflow: hidden; margin-top:5px; box-shadow: 0 0 10px #f00; }
        #hp-bar-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #ff4444, #ff0000); transition: width 0.1s; }
        #hp-regen-text { position: absolute; right: -50px; top: 2px; color: #0f0; font-size: 12px; animation: pulse 1s infinite; }
        @keyframes pulse { 0%{opacity:0.5;} 50%{opacity:1;} 100%{opacity:0.5;} }
        #score-box { position: absolute; top: 20px; left: 20px; color: #fff; font-size: 16px; font-weight: bold; text-shadow: 0 0 5px #000; }
        
        /* Mobile Controls */
        #mobile-controls { display: none; position: absolute; top:0; left:0; width:100%; height:100%; pointer-events: none; }
        #joystick-zone { position: absolute; width: 100px; height: 100px; border: 2px solid rgba(255,255,255,0.2); border-radius: 50%; display: none; transform: translate(-50%, -50%); pointer-events: none; }
        #joystick-knob { position: absolute; width: 40px; height: 40px; background: rgba(0, 255, 255, 0.5); border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none; }
        #dash-btn { 
            position: absolute; bottom: 40px; right: 40px; width: 80px; height: 80px; 
            background: rgba(255, 255, 0, 0.3); border: 2px solid rgba(255, 255, 0, 0.6); 
            border-radius: 50%; pointer-events: auto; display: none;
            justify-content: center; align-items: center; color: #fff; font-size: 30px; user-select: none;
        }
        #dash-btn:active { background: rgba(255, 255, 0, 0.6); transform: scale(0.95); }

        /* Overlays */
        #warning-overlay { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 40%, rgba(200,0,0,0.7) 100%); animation: pulseRed 0.2s infinite alternate; justify-content: center; align-items: center; flex-direction: column; z-index: 10; }
        #warning-text { color: #ff0000; font-size: 60px; font-weight: 900; letter-spacing: 5px; text-shadow: 0 0 20px red; transform: scale(1); animation: textZoom 0.1s infinite alternate; text-align: center; }
        #bomb-overlay { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #fff; z-index: 15; opacity: 0; transition: opacity 0.5s; pointer-events: none; }
        @keyframes pulseRed { from { opacity: 0.2; } to { opacity: 0.8; } }
        @keyframes textZoom { from { transform: scale(0.95); } to { transform: scale(1.05); } }
        
        #menu-overlay, #start-screen, #game-over { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.92); pointer-events: auto; z-index: 20; display: none; justify-content: center; align-items: center; flex-direction: column; }
        #start-screen { display: flex; }
        .card-container { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; max-height: 80vh; overflow-y: auto; padding: 10px; }
        .card { width: 140px; background: #222; border: 1px solid #444; padding: 15px; color: white; cursor: pointer; text-align: center; transition: 0.1s; position: relative; overflow: hidden; border-radius: 8px; flex-shrink: 0; display: flex; flex-direction: column; align-items: center; }
        .card:hover, .card:active { background: #333; border-color: #0ff; transform: translateY(-5px) scale(1.05); box-shadow: 0 0 20px rgba(0,255,255,0.4); }
        
        /* Card Types */
        .card.special { border-color: #ff0; background: #332200; } 
        .card.milestone { border-color: #f0f; background: #220022; }
        .card.milestone:hover { border-color: #fff; background: #440044; box-shadow: 0 0 30px rgba(255,0,255,0.6); }
        
        /* Rare Upgrade Style */
        .card.rare { border-color: #ffd700; background: linear-gradient(135deg, #443300, #221100); box-shadow: 0 0 25px rgba(255, 215, 0, 0.6); animation: glow 2s infinite alternate; }
        .card.rare h3 { color: #ffd700; text-shadow: 0 0 5px #ffaa00; }
        .card.rare p { color: #ffebcd; font-weight: bold; }
        @keyframes glow { from { box-shadow: 0 0 10px #b8860b; } to { box-shadow: 0 0 25px #ffd700; } }

        .card.singularity { border-color: #000; background: #fff; color:#000; box-shadow: 0 0 30px #fff; }
        .card.singularity h3 { color: #000; }
        .card.singularity p { color: #333; }
        
        .card.evo { width: 220px; border-color: #0f0; background: #002211; box-shadow: 0 0 15px #0f0; padding: 20px; }
        .card.evo h3 { color: #0f0; font-size: 18px; margin: 10px 0; border-bottom: 1px solid #0f0; padding-bottom: 5px; width: 100%; }
        .card.evo p { font-size: 12px; color: #dfd; line-height: 1.5; text-align: left; width: 100%; }
        .card.evo .tag { display:inline-block; background:#0f0; color:#000; font-size:10px; padding:2px 5px; border-radius:4px; margin-bottom:5px; font-weight:bold;}

        .card .icon { font-size: 30px; margin-bottom: 5px; display: block; }
        .card h3 { color: #0ff; margin: 5px 0; font-size: 14px; }
        .card.special h3 { color: #ff0; }
        .card.milestone h3 { color: #f0f; }
        .card p { font-size: 11px; color: #ccc; line-height: 1.3; }
        
        button { padding: 20px 50px; font-size: 24px; cursor: pointer; background: #fff; border: none; font-weight: bold; margin-top: 30px; border-radius: 6px; transition: 0.2s; box-shadow: 0 0 10px #fff; }
        button:active { background: #0ff; box-shadow: 0 0 20px #0ff; transform: scale(0.95); }
        
        .singularity-mode #gameCanvas { filter: invert(1) hue-rotate(180deg); }
        .singularity-mode #ui-layer { filter: invert(0); }
    </style>
</head>
<body id="main-body">

<canvas id="gameCanvas"></canvas>

<div id="mobile-controls">
    <div id="joystick-zone"><div id="joystick-knob"></div></div>
    <div id="dash-btn">⚡</div>
</div>

<div id="ui-layer">
    <div id="score-box">SCORE: <span id="disp-score">0</span><br>TIME: <span id="disp-time">00:00</span></div>
    
    <div id="stats-list"></div>
    <div id="top-bar">
        <span style="font-size: 20px; font-weight: bold;">LV <span id="disp-lv">1</span> <span id="disp-class-name" style="font-size:12px; color:#aaa;">(Novice)</span></span>
        <div id="xp-bg"><div id="xp-fill"></div></div>
    </div>
    <div id="skill-list"></div>
    <div id="hp-container">
        HP <span id="disp-hp-val">100</span> / <span id="disp-hp-max">100</span>
        <div id="hp-bar-bg"><div id="hp-bar-fill"></div></div>
        <div id="hp-regen-text">+<span id="disp-regen">1</span>/s</div>
    </div>
</div>

<div id="warning-overlay">
    <div id="warning-text">WARNING</div>
    <div style="color:white; font-size:20px; margin-top:10px; font-weight:bold;">BOSS DETECTED</div>
</div>

<div id="bomb-overlay"></div>

<div id="menu-overlay">
    <h1 id="menu-title" style="color:white; font-size:32px; margin-bottom: 20px; text-shadow: 0 0 15px #0ff;">LEVEL UP!</h1>
    <div class="card-container" id="card-area"></div>
</div>

<div id="start-screen">
    <h1 style="font-size:50px; margin:0; letter-spacing: 5px; color:#fff; text-shadow:0 0 20px #0ff; text-align:center;">EVO LITE</h1>
    <h2 style="color:#00ff88; font-weight:normal; font-size:16px;">v5.5</h2>
    <p style="color:#aaa; margin-top:10px; font-size:12px;">PC: WASD + SPACE | Mobile: Touch & Tap</p>
    <button onclick="startGame()">START</button>
</div>

<div id="game-over">
    <h1 style="color:red; font-size:50px; text-shadow: 0 0 20px red;">DEFEATED</h1>
    <p style="font-size:24px; color:white;">SCORE: <span id="final-score"></span></p>
    <button onclick="location.reload()">RETRY</button>
</div>

<script>
// --- Config ---
const MAX_ENEMIES = 500;
const MAX_PARTICLES = 500; 
const MAX_ORBS = 400; 
const MAX_TEXTS = 50;
const MAX_SOUND_CONCURRENT = 32; 

const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
if(isMobile) {
    document.getElementById('mobile-controls').style.display = 'block';
    document.getElementById('dash-btn').style.display = 'flex';
}

let joyTouchId = null;
let joyStartX = 0, joyStartY = 0;
let joyMoveX = 0, joyMoveY = 0;
const JOY_MAX_RADIUS = 50;

const AudioCtx = window.AudioContext || window.webkitAudioContext;
let actx = null;
let lastSoundTime = {};

// ★ Sound Engine
const Sound = {
    activeEndTimes: [],
    init: () => { 
        if(!actx) {
            actx = new AudioCtx(); 
            const resumeFunc = () => {
                if(actx.state === 'suspended') actx.resume();
                window.removeEventListener('click', resumeFunc);
                window.removeEventListener('touchstart', resumeFunc);
                window.removeEventListener('keydown', resumeFunc);
            };
            window.addEventListener('click', resumeFunc);
            window.addEventListener('touchstart', resumeFunc);
            window.addEventListener('keydown', resumeFunc);
        }
    },
    update: () => {
        if(!actx) return;
        const now = actx.currentTime;
        Sound.activeEndTimes = Sound.activeEndTimes.filter(t => t > now);
    },
    play: (type, pitch = 1.0) => {
        if(!actx) Sound.init();
        if(!actx) return;
        if(actx.state === 'suspended') actx.resume().catch(()=>{});
        if(Sound.activeEndTimes.length >= MAX_SOUND_CONCURRENT) return;

        const now = actx.currentTime;
        if(lastSoundTime[type] && now - lastSoundTime[type] < 0.05) return;
        lastSoundTime[type] = now;

        const osc = actx.createOscillator();
        const gain = actx.createGain();
        osc.connect(gain);
        gain.connect(actx.destination);

        if(level >= 100) pitch *= 0.8;

        let duration = 0.1;
        if(type === 'shoot') {
            duration = 0.1; osc.frequency.setValueAtTime(300 * pitch, now); osc.frequency.exponentialRampToValueAtTime(50, now+0.1); gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now+0.1);
        } else if(type === 'missile') { 
            duration = 0.3; osc.type='square'; osc.frequency.setValueAtTime(150, now); osc.frequency.linearRampToValueAtTime(400, now+0.2); gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now+0.3);
        } else if(type === 'hit') {
            duration = 0.05; osc.type='square'; osc.frequency.setValueAtTime(100 * pitch, now); gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now+0.05);
        } else if(type === 'dash') {
            duration = 0.2; osc.type='triangle'; osc.frequency.setValueAtTime(600, now); osc.frequency.linearRampToValueAtTime(200, now+0.2); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.2);
        } else if(type === 'laser') {
            duration = 0.5; osc.type='sawtooth'; osc.frequency.setValueAtTime(800, now); osc.frequency.linearRampToValueAtTime(200, now+0.5); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.5);
        } else if(type === 'freeze') {
            duration = 0.3; osc.type='sine'; osc.frequency.setValueAtTime(2000, now); osc.frequency.linearRampToValueAtTime(1000, now+0.3); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.3);
        } else if(type === 'explode') {
            duration = 0.2; osc.type='sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.exponentialRampToValueAtTime(10, now+0.2); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.2);
        } else if(type === 'levelup') {
            duration = 0.6; osc.type='triangle'; osc.frequency.setValueAtTime(440, now); osc.frequency.setValueAtTime(554, now+0.1); osc.frequency.setValueAtTime(659, now+0.2); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.6);
        } else if(type === 'milestone') {
            duration = 0.8; osc.type='sawtooth'; osc.frequency.setValueAtTime(110, now); osc.frequency.linearRampToValueAtTime(440, now+0.8); gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now+0.8);
        } else if(type === 'alert') {
            duration = 0.5; osc.type='sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.linearRampToValueAtTime(150, now+0.5); gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now+0.5);
        } else if(type === 'exp') {
            duration = 0.1; osc.type='sine'; let freq = 1000 * pitch; osc.frequency.setValueAtTime(freq, now); osc.frequency.linearRampToValueAtTime(freq + 500, now+0.05); gain.gain.setValueAtTime(0.03, now); gain.gain.linearRampToValueAtTime(0, now+0.1);
        } else if(type === 'bounce') {
            duration = 0.1; osc.type='triangle'; osc.frequency.setValueAtTime(600, now); osc.frequency.linearRampToValueAtTime(300, now+0.1); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.1);
        } else if(type === 'bash') {
            duration = 0.2; osc.type='square'; osc.frequency.setValueAtTime(100, now); osc.frequency.linearRampToValueAtTime(50, now+0.2); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.2);
        } else if(type === 'lightning') {
            duration = 0.2; osc.type='sawtooth'; osc.frequency.setValueAtTime(800, now); osc.frequency.linearRampToValueAtTime(100, now+0.2); gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now+0.2);
        } else if(type === 'spark') {
            duration = 0.15; osc.type='sawtooth'; osc.frequency.setValueAtTime(2000, now); osc.frequency.linearRampToValueAtTime(500, now+0.15); gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now+0.15);
        } else if(type === 'powerup') {
            duration = 0.5; osc.type='sine'; osc.frequency.setValueAtTime(440, now); osc.frequency.linearRampToValueAtTime(880, now+0.25); osc.frequency.linearRampToValueAtTime(1760, now+0.5); gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now+0.5);
        } else if(type === 'bomb') {
            duration = 1.0; osc.type='sawtooth'; osc.frequency.setValueAtTime(50, now); osc.frequency.linearRampToValueAtTime(20, now+1.0); gain.gain.setValueAtTime(0.5, now); gain.gain.linearRampToValueAtTime(0, now+1.0);
        }
        osc.start(now); osc.stop(now + duration);
        Sound.activeEndTimes.push(now + duration + 0.05);
    }
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let scaleFactor = 1;
function resizeCanvas() {
    let winW = window.innerWidth;
    let winH = window.innerHeight;
    const isPortrait = winH > winW;
    const targetWidth = isPortrait ? 900 : 1600;
    scaleFactor = winW < targetWidth ? targetWidth / winW : 1;
    canvas.width = winW * scaleFactor;
    canvas.height = winH * scaleFactor;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas(); 

let lastTime = 0;
let startTime = 0;
let gameActive = false;
let score = 0;
let level = 1;
let exp = 0;
let nextExp = 50; 
let screenShake = 0;
let bossCycleCounter = 0; 
let bossWarningTimer = 0;
let bossWarningActive = false; 
let earthquakeTimer = 0;
let electroFenceTimer = 0; 
let singularityMode = false;

// Guardian Sentry
let sentries = [];
let sentryTimer = 0;

// Items
let items = [];

let player = {
    x: canvas.width/2, y: canvas.height/2, size: 15,
    hp: 100, maxHp: 100,
    class: 'Novice', subClass: null, color: '#00ffff',
    invincible: 0,
    dashCd: 0, maxDashCd: 120,
    slamCd: 0,
    laserCd: 0, freezeCd: 0,
    // Unique states
    sunCharge: 0, // Crusader
    isMoving: false
};

let stats = {
    critChance: 0.05, // 会心率（初期値5%）
    dodge: 0,         // 回避率
    areaScale: 1.0,   // 攻撃サイズ倍率
    duration: 1.0,    // 持続時間倍率（毒や設置物用）
    knockback: 0,     // ノックバック力
    critMult: 2.0,   // クリティカル時のダメージ倍率（最初は2倍）
    hpDamage: 0,     // 敵の最大HPの何%を削るか（最初は0%）
    lowHpDmg: false,
    spd: 7, dmg: 15, rate: 25, multi: 1, 
    bulletSpeed: 16, pierce: 0, 
    aura: false, auraRange: 0,
    regen: 1, magnet: 150, 
    homing: 0, lightning: 0, poison: 0, spinBlade: 0, chakram: 0,
    missile: 0, drones: 0, auraScale: 1,
    lifesteal: 0, infinitePierce: false,
    missileBlast: 1, gravityAura: false, spreadShot: false,
    napalm: false, spikeArmor: false, dashNova: false, 
    splitShot: false, giantSlayer: false,
    armor: 0, 
    knockback: 0, shrapnel: false, 
    
    // Guardian Skills
    sentrySystem: false, siegeMode: false, reactiveArmor: false, 
    nanoRepair: false, clusterMine: false, forceField: false,
    forceFieldCd: 0, isStationary: false,
    sentryMax: 5, sentryRate: 1.0,
    
    // Forbidden Skills
    shotExplode: false, shotBounce: false, doubleShot: false, 
    missileChance: 0, infiniteMag: false, gatling: false,
    titan: false, blackHole: false, bladeStorm: false, 
    earthquake: false, spikeReflect: false, bloodLust: false,
    railgun: false, execute: false, deadeye: false, 
    electroFence: false, chainBurst: false, orbital: false,
    omegaLaser: false, absoluteZero: false, necromancer: false,

    // Sub Class Specifics
    ghostShot: false, // Dimension Walker
    prismSplit: false, // Prism Shooter
    isEarthShaker: false,
    teslaGrid: false,
    bulletStorm: false, // Assault B
    clusterStriker: false // Assault A
};

let bullets = [];
let enemyBullets = [];
let enemies = [];
let particles = [];
let expOrbs = [];
let texts = [];
let orbitals = [];
let drones = []; 
let gasClouds = [];
let spikeBits = [];
// Flying Swords
let flyingSwords = [];

// --- Input Handling (PC & Mobile Improved) ---
const keys = {};

window.addEventListener('keydown', e => { keys[e.key] = true; if(e.code === 'Space') dash(); });
window.addEventListener('keyup', e => keys[e.key] = false);

// ダッシュボタンの処理
const dashBtn = document.getElementById('dash-btn');
if(dashBtn) {
    dashBtn.addEventListener('touchstart', (e) => { 
        e.preventDefault(); 
        dash(); 
    }, {passive: false});
}

// ヘルパー：タッチした場所がボタンやカードかどうか判定
function isInteractive(target) {
    // ボタン、またはカード（レベルアップ選択肢）の上なら true
    return target.tagName === 'BUTTON' || target.closest('.card') || target.id === 'dash-btn';
}

// ジョイスティック処理（修正版 v2）
const handleTouchStart = (e) => {
    // ボタンやカードを触った時は preventDefault しない（クリックできるようにする）
    if(!isInteractive(e.target)) {
        if(e.cancelable) e.preventDefault();
    }

    for(let i=0; i<e.changedTouches.length; i++) {
        let t = e.changedTouches[i];
        
        // 画面左半分を触ったらジョイスティック開始
        // ただしスタート画面などが表示されている時はジョイスティックを反応させない
        if(gameActive && t.clientX < window.innerWidth / 2 && joyTouchId === null) {
            joyTouchId = t.identifier;
            joyStartX = t.clientX;
            joyStartY = t.clientY;
            
            let zone = document.getElementById('joystick-zone');
            zone.style.display = 'block';
            zone.style.left = joyStartX + 'px';
            zone.style.top = joyStartY + 'px';
            
            let knob = document.getElementById('joystick-knob');
            knob.style.transform = `translate(-50%, -50%)`;
            
            updateJoystick(t.clientX, t.clientY);
        }
    }
};

const handleTouchMove = (e) => {
    // 移動中は基本preventDefaultしたいが、ボタン上なら許可（スクロールは防ぎたいので条件分岐）
    if(e.cancelable) e.preventDefault();
    
    for(let i=0; i<e.changedTouches.length; i++) {
        let t = e.changedTouches[i];
        if(t.identifier === joyTouchId) {
            updateJoystick(t.clientX, t.clientY);
        }
    }
};

const handleTouchEnd = (e) => {
    // ★ここが修正点：ボタンの上で指を離した時は preventDefault しない！
    if(!isInteractive(e.target)) {
        if(e.cancelable) e.preventDefault();
    }
    
    for(let i=0; i<e.changedTouches.length; i++) {
        let t = e.changedTouches[i];
        if(t.identifier === joyTouchId) {
            resetJoystick();
        }
    }
};

const handleTouchCancel = (e) => {
    if(e.cancelable) e.preventDefault();
    for(let i=0; i<e.changedTouches.length; i++) {
        let t = e.changedTouches[i];
        if(t.identifier === joyTouchId) {
            resetJoystick();
        }
    }
};

function resetJoystick() {
    joyTouchId = null;
    joyMoveX = 0; joyMoveY = 0;
    let zone = document.getElementById('joystick-zone');
    if(zone) zone.style.display = 'none';
    let knob = document.getElementById('joystick-knob');
    if(knob) knob.style.transform = `translate(-50%, -50%)`;
}

window.addEventListener('touchstart', handleTouchStart, {passive: false});
window.addEventListener('touchmove', handleTouchMove, {passive: false});
window.addEventListener('touchend', handleTouchEnd, {passive: false});
window.addEventListener('touchcancel', handleTouchCancel, {passive: false});

function updateJoystick(cx, cy) {
    let dx = cx - joyStartX;
    let dy = cy - joyStartY;
    let dist = Math.hypot(dx, dy);
    
    if(dist > JOY_MAX_RADIUS) {
        let ratio = JOY_MAX_RADIUS / dist;
        dx *= ratio;
        dy *= ratio;
    }
    
    joyMoveX = dx / JOY_MAX_RADIUS;
    joyMoveY = dy / JOY_MAX_RADIUS;
    
    let knob = document.getElementById('joystick-knob');
    if(knob) knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
}


function startGame() {
    document.getElementById('start-screen').style.display = 'none';
    Sound.init();
    Sound.play('levelup');
    gameActive = true;
    player.x = canvas.width/2;
    player.y = canvas.height/2;
    startTime = Date.now();
    lastTime = performance.now();
    updateSkillList();
    updateUI(); // Init UI text
    requestAnimationFrame(loop);
}

function loop(timestamp) {
    if(!gameActive) return;
    const dt = timestamp - lastTime;
    lastTime = timestamp;
    let timeScale = dt / (1000 / 60);
    if(timeScale > 4) timeScale = 4;
    
    Sound.update();

    update(timeScale);
    draw();
    requestAnimationFrame(loop);
}

function update(ts) {
    let gameTimeSec = (Date.now() - startTime) / 1000;
    
    if(level >= 100 && !singularityMode) {
        singularityMode = true;
        document.body.classList.add('singularity-mode');
        Sound.play('milestone');
    }

    let m = Math.floor(gameTimeSec/60);
    let s = Math.floor(gameTimeSec%60);
    document.getElementById('disp-time').innerText = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;

    if(player.dashCd > 0) player.dashCd -= ts;
    if(player.invincible > 0) player.invincible -= ts;
    if(player.slamCd > 0) player.slamCd -= ts;
    if(screenShake > 0) screenShake *= 0.9;
    
    // Guardian Skills Update
    if(stats.sentrySystem) {
        let sentrySpawnRate = 600 / stats.sentryRate; 
        sentryTimer -= ts;
        if(sentryTimer <= 0) {
            spawnSentry();
            sentryTimer = sentrySpawnRate; 
        }
        sentries.forEach(s => {
            s.cooldown -= ts;
            if(s.cooldown <= 0) {
                let target = null;
                let minDSq = 400 * 400; 
                enemies.forEach(e => {
                    if(e.dead) return;
                    let dSq = (e.x - s.x)**2 + (e.y - s.y)**2;
                    if(dSq < minDSq) { minDSq = dSq; target = e; }
                });
                if(target) {
                    let ang = Math.atan2(target.y - s.y, target.x - s.x);
                    let fireDelay = Math.max(5, stats.rate * (1/stats.sentryRate));
                    bullets.push({type:'normal', x:s.x, y:s.y, vx:Math.cos(ang)*stats.bulletSpeed, vy:Math.sin(ang)*stats.bulletSpeed, size:6, color:'#0f0', hit:[], pierce:stats.pierce});
                    Sound.play('shoot', 1.5);
                    s.cooldown = fireDelay;
                }
            }
        });
        
        if(stats.teslaGrid && sentries.length >= 2) {
            for(let i=0; i<sentries.length; i++) {
                let s1 = sentries[i];
                let s2 = sentries[(i+1)%sentries.length];
                enemies.forEach(e => {
                    if(e.dead) return;
                    let dist = pointToLineDistance(e.x, e.y, s1.x, s1.y, s2.x, s2.y);
                    if(dist < e.size + 5) {
                        damageEnemy(e, stats.dmg * 2.0);
                        if(Math.random()<0.2*ts) createParticles(e.x, e.y, '#0ff', 2, 2);
                    }
                });
            }
        }
    }

    if(stats.forceField) {
        if(stats.forceFieldCd > 0) stats.forceFieldCd -= ts;
    }

    if(stats.nanoRepair && player.hp < player.maxHp * 0.3) {
        player.hp = Math.min(player.maxHp, player.hp + (50/60)*ts);
    }

    if(stats.slotMachine) {
        if(typeof player.slotTimer === 'undefined') player.slotTimer = 300;
        player.slotTimer -= ts;
        if(player.slotTimer <= 0) {
            player.slotTimer = 300; 
            Sound.play('powerup');
            let luck = Math.random();
            if(luck < 0.3) {
                stats.rate = 2; 
                if(texts.length < MAX_TEXTS) texts.push({x:player.x, y:player.y-20, str:"FEVER!!", life:60, color:'#ff0'});
            } else if(luck < 0.6) {
                stats.bulletSpeed = 40; 
                texts.push({x:player.x, y:player.y-20, str:"SPEED UP!", life:60, color:'#0ff'});
            } else if(luck < 0.8) {
                player.size = 50; 
                texts.push({x:player.x, y:player.y-20, str:"BIG MODE", life:60, color:'#f00'});
            } else {
                stats.multi = 10; 
                texts.push({x:player.x, y:player.y-20, str:"MULTI!!", life:60, color:'#f0f'});
            }
            setTimeout(()=>{ 
                stats.rate = 5; stats.bulletSpeed = 16; player.size = 15; stats.multi = 1; 
            }, 3000);
        }
    }

    if(stats.omegaLaser) {
        player.laserCd -= ts;
        if(player.laserCd <= 0) { fireOmegaLaser(); player.laserCd = 180; }
    }
    
    if(stats.tempestMode) {
        if(Math.random() < 0.1 * ts) { 
            let targets = enemies.filter(e => !e.dead && Math.hypot(e.x-player.x, e.y-player.y) < 500);
            if(targets.length > 0) {
                let target = targets[Math.floor(Math.random() * targets.length)];
                triggerLightning(target, stats.lightning);
            }
        }
    }

    if(stats.absoluteZero) {
        enemies.forEach(e => {
            // 範囲を 250 → 180 に少し縮小（近づかないと効果が出ないように）
            if(!e.dead && Math.hypot(e.x-player.x, e.y-player.y) < 200) {
                // 【変更点】
                // 毎回 e.frozen=5 にすると完全停止するため、
                // 「50%の確率で一瞬止める」ことで、カクカク動きながら近づいてくる「減速」効果にします。
                if(Math.random() < 0.5) {
                    e.frozen = 2; 
                }
            }
        });
        // パーティクル演出はそのまま
        if(Math.random() < 0.2*ts && particles.length < MAX_PARTICLES) createParticles(player.x + (Math.random()-0.5)*500, player.y + (Math.random()-0.5)*500, '#88ffff', 1, 1);
    }
    if(stats.earthquake) {
        earthquakeTimer -= ts;
        if(earthquakeTimer <= 0) {
            earthquakeTimer = 120; 
            screenShake = 15; Sound.play('bash');
            enemies.forEach(e => { if(!e.dead) damageEnemy(e, stats.dmg * 2); });
            particles.push({type:'shockwave', x:player.x, y:player.y, size:400, life:30, color:'#f80'});
        }
    }
    if(stats.electroFence) {
        electroFenceTimer -= ts;
        if(electroFenceTimer <= 0) {
            electroFenceTimer = 60; 
            let r = 150;
            Sound.play('spark');
            particles.push({type:'shockwave', x:player.x, y:player.y, size:r, life:20, color:'#88ffff'});
            enemies.forEach(e => {
                if(!e.dead && Math.hypot(e.x-player.x, e.y-player.y) < r + e.size) {
                    damageEnemy(e, stats.dmg);
                    e.frozen = 30; 
                    let ang = Math.atan2(e.y-player.y, e.x-player.x);
                    e.x += Math.cos(ang) * 30; e.y += Math.sin(ang) * 30; 
                    createLightningEffect(player.x, player.y, e.x, e.y);
                }
            });
        }
    }

    if(stats.orbital && Math.random() < 0.05 * ts) {
        let t = enemies[Math.floor(Math.random()*enemies.length)];
        if(t && !t.dead) {
            createParticles(t.x, t.y, '#f0f', 10, 3);
            damageEnemy(t, stats.dmg * 5);
            Sound.play('laser');
            particles.push({type:'shockwave', x:t.x, y:t.y, size:50, life:10, color:'#f0f'});
        }
    }

    if(Math.random() < (1/60) * ts && player.hp < player.maxHp) {
        player.hp = Math.min(player.maxHp, player.hp + stats.regen);
        updateUI();
    }

    let dx = 0, dy = 0;
    if(keys['w'] || keys['ArrowUp']) dy = -1;
    if(keys['s'] || keys['ArrowDown']) dy = 1;
    if(keys['a'] || keys['ArrowLeft']) dx = -1;
    if(keys['d'] || keys['ArrowRight']) dx = 1;

    if(joyTouchId !== null) { dx = joyMoveX; dy = joyMoveY; }

    if(dx!==0 || dy!==0) {
        let len = Math.hypot(dx, dy);
        if(len > 1) { dx/=len; dy/=len; }
        player.x += dx * stats.spd * ts;
        player.y += dy * stats.spd * ts;
        stats.isStationary = false;
        player.isMoving = true;
    } else {
        stats.isStationary = true;
        player.isMoving = false;
    }

    player.x = Math.max(15, Math.min(canvas.width-15, player.x));
    player.y = Math.max(15, Math.min(canvas.height-15, player.y));

    if(stats.isEarthShaker && player.isMoving) {
        if(Math.floor(Date.now() / 200) % 2 === 0) { 
            screenShake = 2;
            enemies.forEach(e => {
                if(!e.dead && Math.hypot(e.x-player.x, e.y-player.y) < player.size + 40) {
                    damageEnemy(e, stats.dmg * 0.5); 
                    let pushAng = Math.atan2(e.y - player.y, e.x - player.x);
                    e.x += Math.cos(pushAng) * 10 * ts; e.y += Math.sin(pushAng) * 10 * ts; 
                }
            });
        }
    }

    // --- Skills ---
    if(player.class === 'Melee' && (stats.multi > 0 || stats.bladeStorm)) {
        let count = stats.multi + (stats.bladeStorm ? 4 : 0);
        if(player.subClass === 'FlyingSwords') {
             if(flyingSwords.length !== count) {
                 flyingSwords = [];
                 for(let i=0; i<count; i++) flyingSwords.push({x:player.x, y:player.y, target:null, cooldown:0});
             }
             flyingSwords.forEach(sw => {
                 if(sw.cooldown > 0) sw.cooldown -= ts;
                 if(!sw.target || sw.target.dead || Math.hypot(sw.target.x-player.x, sw.target.y-player.y) > 400) {
                     sw.target = null;
                     let minD = 350;
                     enemies.forEach(e => {
                         if(e.dead) return;
                         let d = Math.hypot(e.x-player.x, e.y-player.y);
                         if(d < minD) { minD=d; sw.target=e; }
                     });
                 }
                 let tx, ty;
                 if(sw.target) {
                     tx = sw.target.x; ty = sw.target.y;
                 } else {
                     let angle = Date.now() * 0.002 + (flyingSwords.indexOf(sw) * (Math.PI*2/count));
                     tx = player.x + Math.cos(angle) * 80;
                     ty = player.y + Math.sin(angle) * 80;
                 }
                 sw.x += (tx - sw.x) * 0.15 * ts;
                 sw.y += (ty - sw.y) * 0.15 * ts;
                 enemies.forEach(e => {
                     if(!e.dead && Math.hypot(e.x-sw.x, e.y-sw.y) < 15 && sw.cooldown <= 0) {
                         damageEnemy(e, stats.dmg * 0.8);
                         createParticles(e.x, e.y, '#f0a', 1, 1);
                         sw.cooldown = 15; 
                     }
                 });
             });
        } else {
            if(spikeBits.length !== count) {
                spikeBits = []; for(let i=0; i<count; i++) spikeBits.push({angle:0});
            }
            let rotSpd = 0.1 * ts;
            spikeBits.forEach((bit, i) => {
                bit.angle += rotSpd;
                let currentAngle = bit.angle + (Math.PI*2/count)*i;
                let radius = 25 + player.size/2 + (stats.titan ? 20 : 0);
                if(stats.isColossus) radius += 20;
                bit.x = player.x + Math.cos(currentAngle) * radius;
                bit.y = player.y + Math.sin(currentAngle) * radius;
                enemies.forEach(e => {
                    if(!e.dead && Math.hypot(e.x-bit.x, e.y-bit.y) < 15 + e.size) {
                        if(Math.random() < 0.1 * ts) damageEnemy(e, stats.dmg * 0.5);
                    }
                });
            });
        }
    }

    if(stats.missile > 0) {
        // タイマー変数がなければ初期化
        if(typeof player.missileCd === 'undefined') player.missileCd = 0;
        
        player.missileCd -= ts;
        if(player.missileCd <= 0) {
            fireMissile();
            // レベルが高いほど間隔が短くなる計算式
            let missileInterval = Math.max(10, 60 - stats.missile * 5);
            player.missileCd = missileInterval;
        }
    }

    if(drones.length < stats.drones) {
        drones.push({ x: player.x, y: player.y, angle: Math.random()*Math.PI*2, state: 'orbit', target: null, timer: 0 });
    }
    let droneSpeedMult = stats.drones > 2 ? 1.5 : 1.0; 
    
    drones.forEach(d => {
        if(d.state === 'orbit') {
            d.angle += 0.05 * ts * droneSpeedMult;
            let ox = player.x + Math.cos(d.angle) * 80;
            let oy = player.y + Math.sin(d.angle) * 80;
            d.x += (ox - d.x) * 0.1 * ts; d.y += (oy - d.y) * 0.1 * ts;
            let minD = 350;
            enemies.forEach(e => {
                if(e.dead) return;
                let dist = Math.hypot(e.x - player.x, e.y - player.y);
                if(dist < minD) { minD = dist; d.target = e; d.state = 'attack'; }
            });
        } else if(d.state === 'attack') {
            if(!d.target || d.target.dead) { d.state = 'return'; return; }
            let ang = Math.atan2(d.target.y - d.y, d.target.x - d.x);
            d.x += Math.cos(ang) * 12 * ts * droneSpeedMult; d.y += Math.sin(ang) * 12 * ts * droneSpeedMult;
            if(Math.hypot(d.x - d.target.x, d.y - d.target.y) < 20) {
                damageEnemy(d.target, stats.dmg * 2);
                if(stats.lightning > 0) triggerLightning(d.target, stats.lightning);
                if(particles.length < MAX_PARTICLES) createParticles(d.x, d.y, '#ff0', 5, 2);
                d.state = 'return'; d.timer = 30 / droneSpeedMult; 
            }
        } else if(d.state === 'return') {
            d.timer -= ts;
            if(d.timer <= 0) {
                let ox = player.x + Math.cos(d.angle) * 80;
                let oy = player.y + Math.sin(d.angle) * 80;
                let ang = Math.atan2(oy - d.y, ox - d.x);
                d.x += Math.cos(ang) * 15 * ts; d.y += Math.sin(ang) * 15 * ts;
                if(Math.hypot(ox - d.x, oy - d.y) < 20) d.state = 'orbit';
            }
        }
    });

    if(stats.doppelganger) {
        if(!player.clone) player.clone = {x:player.x, y:player.y};
        let lerp = 0.1;
        let targetX = player.x - (player.isMoving ? Math.sign(player.x - player.clone.x)*40 : 40);
        player.clone.x += (targetX - player.clone.x) * lerp;
        player.clone.y += (player.y - player.clone.y) * lerp;
    }

    if(stats.poison > 0 && Math.random() < (1/30)*ts) {
        let target = null;
        let minD = 500; 
        enemies.forEach(e => {
            if(e.dead) return;
            let d = Math.hypot(e.x - player.x, e.y - player.y);
            if(d < minD) { minD = d; target = e; }
        });
        let spawnX = target ? target.x : player.x;
        let spawnY = target ? target.y : player.y;

        gasClouds.push({ 
            x: spawnX, y: spawnY, 
            // 【修正】変数がなくても動くように ( || 1.0 ) を追加しました
            r: (30 + (stats.poison * 10)) * (stats.areaScale || 1.0), 
            life: (180 + (stats.poison * 30)) * (stats.duration || 1.0), 
            dmg: stats.dmg * (0.2 + stats.poison * 0.1),
            tick: 0 
        });
    }

    // 2. 毒のダメージ処理（確率ではなく一定時間ごとに確定ヒットさせる）
    for(let i=gasClouds.length-1; i>=0; i--) {
        let g = gasClouds[i]; 
        g.life -= ts;
        
        if(typeof g.tick === 'undefined') g.tick = 0;
        g.tick -= ts;
        
        // 約0.25秒(15フレーム)ごとに判定
        if(g.tick <= 0) {
            g.tick = 15; 
            enemies.forEach(e => { 
                if(!e.dead && Math.hypot(e.x - g.x, e.y - g.y) < g.r + e.size) {
                    damageEnemy(e, g.dmg);
                    if(Math.random() < 0.3) createParticles(e.x, e.y, '#aa00ff', 1, 2);
                } 
            }); 
        }
        
        if(g.life <= 0) gasClouds.splice(i, 1);
    }

    if(stats.spinBlade > 0) {
        let orbitalSpeed = (Date.now() / 1000) * 2;
        if(orbitals.length !== stats.spinBlade) { orbitals = []; for(let i=0; i<stats.spinBlade; i++) orbitals.push({}); }
        orbitals.forEach((orb, i) => {
            let angle = orbitalSpeed + (Math.PI * 2 / stats.spinBlade) * i;
            orb.x = player.x + Math.cos(angle) * 110; orb.y = player.y + Math.sin(angle) * 110;
            enemies.forEach(e => { 
                if(!e.dead && Math.hypot(e.x-orb.x, e.y-orb.y) < 20 + e.size && Math.random() < 0.12 * ts) damageEnemy(e, stats.dmg * 1.5); 
            });
        });
    }

    // --- 検索用: if(stats.aura) ---
    if(stats.aura) {
        let r = stats.auraRange * stats.auraScale;
        let auraRate = 0.1;
        if(player.class === 'Melee' && stats.homing > 0) auraRate += (stats.homing * 0.05);
        
        // ★ SunCrusherの処理（そのまま）
        if(player.subClass === 'SunCrusher') {
            if(player.isMoving) {
                if(player.sunCharge > 0) {
                    player.sunCharge -= ts * 5; 
                    r += player.sunCharge * 2; 
                    auraRate = 0.5; 
                    if(Math.random() < 0.3) createParticles(player.x+(Math.random()-0.5)*r, player.y+(Math.random()-0.5)*r, '#fa0', 1, 3);
                }
            } else {
                player.sunCharge = Math.min(100, player.sunCharge + ts);
                r = 10; 
                if(Math.random()<0.1) createParticles(player.x, player.y, '#fa0', 1, 1);
            }
        }

        enemies.forEach(e => { 
            if(e.dead) return;
            let dist = Math.hypot(e.x-player.x, e.y-player.y);
            if(dist < r + e.size) {
                if(Math.random() < auraRate * ts) {
                    // ★【変更点】ここから火力を強化
                    let d = stats.dmg;
                    
                    // ヴァンガード/ガーディアン系なら「最大HP」と「防御力」を火力に変換！
                    if(player.class === 'Melee' || player.class === 'Guardian') {
                        let hpBonus = player.maxHp * 0.05; // 最大HPの5%を加算
                        let armorBonus = stats.armor * 10; // 防御力の10倍を加算
                        d += hpBonus + armorBonus;
                    }

                    if(player.subClass === 'SunCrusher' && player.isMoving) d *= (1 + player.sunCharge/20);
                    
                    damageEnemy(e, d);
                    // ★【変更点】ここまで

                    if(player.class === 'Melee' && stats.lightning > 0 && Math.random() < 0.3) {
                        triggerLightning(e, stats.lightning);
                    }
                }
                if(stats.gravityAura || stats.blackHole) {
                    let pull = (stats.blackHole ? 3.0 : 1.0) * ts; 
                    e.x += (player.x - e.x) / dist * pull;
                    e.y += (player.y - e.y) / dist * pull;
                    e.x -= Math.cos(Math.atan2(player.y-e.y, player.x-e.x)) * (e.speed*0.5) * ts; 
                    e.y -= Math.sin(Math.atan2(player.y-e.y, player.x-e.x)) * (e.speed*0.5) * ts;
                }
            } 
        });
    }

    let currentRate = stats.rate;
    if(stats.siegeMode && stats.isStationary) currentRate /= 2;
    if(stats.bulletStorm) currentRate = 3; 

    // ★ここから修正後のコード★
    if(!stats.aura) {
        // タイマー変数がなければ0で初期化
        if(typeof player.shootCd === 'undefined') player.shootCd = 0;

        // 時間を経過させる
        player.shootCd -= ts;
        
        // タイマーが0以下になったら発射！
        if(player.shootCd <= 0) {
            shoot();
            
            // ついでにチャクラムも投げる
            if(stats.chakram > 0 && Math.random() < 0.3) fireChakram();

            // 次の発射までの時間をセット（これで等間隔になります）
            player.shootCd = currentRate;
        }
    }

    // --- Bullets ---
    let boundary = 200; 
    for(let i=bullets.length-1; i>=0; i--) {
        let b = bullets[i];
        
        // --- 侍の斬撃処理 (Slash) - 超軽量化版 ---
        if(b.type === 'slash') {
            b.x += b.vx * ts; b.y += b.vy * ts; 
            b.life -= ts;
            
            if(b.life > 12) {
                let effectsSpawned = 0;
                const MAX_EFFECTS_PER_FRAME = 3;

                enemies.forEach(e => {
                    // ★修正: includes -> has
                    if(e.dead || b.hit.has(e.id)) return; 
                    
                    let range = b.size + e.size;
                    if(Math.abs(b.x - e.x) > range || Math.abs(b.y - e.y) > range) return;

                    if((b.x - e.x)**2 + (b.y - e.y)**2 < range * range) {
                        damageEnemy(e, stats.dmg * 2.0); 
                        
                        if(effectsSpawned < MAX_EFFECTS_PER_FRAME && Math.random() < 0.3) {
                            createParticles(e.x, e.y, '#fff', 3, 2); 
                            // ... (エフェクト処理省略) ...
                            effectsSpawned++;
                        } else if(stats.lightning > 0 && Math.random() < 0.05) {
                            triggerLightning(e, stats.lightning);
                        }

                        // ★修正: push -> add
                        b.hit.add(e.id);
                    }
                });
            }

            if(b.life <= 0) { bullets.splice(i, 1); }
            continue;
        }

        if(b.type === 'omega') {
            b.x += b.vx * ts; b.y += b.vy * ts; b.life -= ts;
            b.tick = (b.tick || 0) + ts;
            if(b.tick >= 5) {
                b.tick = 0;
                enemies.forEach(e => {
                    if(!e.dead && Math.abs(e.x - b.x) < b.size && Math.abs(e.y - b.y) < b.size) {
                        damageEnemy(e, stats.dmg * 5); 
                        if(particles.length < MAX_PARTICLES && Math.random() < 0.3) createParticles(e.x, e.y, '#f0f', 1, 1);
                    }
                });
            }
            if(b.life <= 0) { bullets.splice(i,1); }
            continue;
        }

        if(b.type === 'chakram') {
            b.x += b.vx * ts; b.y += b.vy * ts; b.life -= ts; 
            if(b.life <= 0) { bullets.splice(i, 1); continue; }
            if(b.x < 0 || b.x > canvas.width) { b.vx *= -1; b.x = Math.max(0, Math.min(canvas.width, b.x)); Sound.play('bounce'); }
            if(b.y < 0 || b.y > canvas.height) { b.vy *= -1; b.y = Math.max(0, Math.min(canvas.height, b.y)); Sound.play('bounce'); }
            for(let j=enemies.length-1; j>=0; j--) {
                let e = enemies[j];
                if(e.dead || b.hit.includes(e.id)) continue;
                if(Math.hypot(b.x-e.x, b.y-e.y) < b.size + e.size) {
                    damageEnemy(e, stats.dmg * 1.5);
                    if(particles.length < MAX_PARTICLES) createParticles(b.x, b.y, '#0ff', 2, 2);
                    if(b.bounceCd <= 0) {
                        let ang = Math.atan2(b.y - e.y, b.x - e.x); 
                        let spd = Math.hypot(b.vx, b.vy);
                        b.vx = Math.cos(ang) * spd; b.vy = Math.sin(ang) * spd;
                        b.bounceCd = 10;
                        Sound.play('bounce');
                    }
                }
            }
            if(b.bounceCd > 0) b.bounceCd -= ts;
            if(Math.random()<0.3 && particles.length < MAX_PARTICLES) createParticles(b.x, b.y, '#8ff', 1, 1);
            continue;
        }
        
        if(b.type !== 'missile' && stats.homing > 0) {
            let detectRange = 250 + (stats.homing * 50); 
            let target = null, minDSq = detectRange * detectRange;
            enemies.forEach(e => { 
                if(e.dead) return; 
                let dSq = (e.x-b.x)**2 + (e.y-b.y)**2;
                if(dSq < minDSq && !b.hit.includes(e.id)) { minDSq = dSq; target = e; } 
            });
            
            if(target) {
                let desiredAngle = Math.atan2(target.y - b.y, target.x - b.x);
                let currentAngle = Math.atan2(b.vy, b.vx);
                let turnSpeed = (0.05 + (stats.homing * 0.05)) * ts; 
                let diff = desiredAngle - currentAngle;
                if(diff > Math.PI) diff -= Math.PI*2; if(diff < -Math.PI) diff += Math.PI*2;
                if(Math.abs(diff) < Math.PI) {
                    currentAngle += Math.sign(diff) * Math.min(Math.abs(diff), turnSpeed);
                    let speed = Math.hypot(b.vx, b.vy);
                    b.vx = Math.cos(currentAngle) * speed; b.vy = Math.sin(currentAngle) * speed;
                }
            }
        }

        if(b.type === 'missile' || b.type === 'spirit') {
            let minD = 400, target = null;
            enemies.forEach(e => { if(e.dead) return; let d = Math.hypot(e.x-b.x, e.y-b.y); if(d < minD) { minD=d; target=e; } });
            if(target) {
                let ang = Math.atan2(target.y - b.y, target.x - b.x);
                let cur = Math.atan2(b.vy, b.vx);
                let diff = ang - cur;
                if(diff > Math.PI) diff -= Math.PI*2; if(diff < -Math.PI) diff += Math.PI*2;
                cur += Math.sign(diff) * 0.1 * ts;
                b.vx = Math.cos(cur) * b.speed; b.vy = Math.sin(cur) * b.speed;
            }
            b.x += b.vx * ts; b.y += b.vy * ts; 
            if(Math.random() < 0.5 * ts && particles.length < MAX_PARTICLES) createParticles(b.x, b.y, b.type==='spirit'?'#8f8':'#f80', 1, 2);
        } else {
            b.x += b.vx * ts; b.y += b.vy * ts;
            if(b.life !== undefined) {
                b.life -= ts;
                if(b.life <= 0) { bullets.splice(i, 1); continue; }
            }
            if(stats.ghostShot) {
                let wrapped = false;
                if(b.x < 0) { b.x = canvas.width; wrapped=true; }
                else if(b.x > canvas.width) { b.x = 0; wrapped=true; }
                if(b.y < 0) { b.y = canvas.height; wrapped=true; }
                else if(b.y > canvas.height) { b.y = 0; wrapped=true; }
                if(wrapped) {
                    b.size = Math.min(50, b.size * 1.5); 
                    b.damageMult = Math.min(8.0, (b.damageMult || 1) * 1.5);
                    if(b.life === undefined) b.life = 180; 
                    b.life -= 60; 
                    if(b.life <= 0) { bullets.splice(i, 1); continue; }
                    b.pierce = 999; 
                }
            }
        }

        if(stats.shotBounce && (b.type === 'normal')) {
            if(b.x < 0 || b.x > canvas.width) { b.vx *= -1; b.x = Math.max(0, Math.min(canvas.width, b.x)); Sound.play('bounce'); }
            if(b.y < 0 || b.y > canvas.height) { b.vy *= -1; b.y = Math.max(0, Math.min(canvas.height, b.y)); Sound.play('bounce'); }
        }
        
        if(!stats.ghostShot && (b.x < -boundary || b.x > canvas.width+boundary || b.y < -boundary || b.y > canvas.height+boundary)) { bullets.splice(i, 1); continue; }

        let hit = false;
        for(let j=enemies.length-1; j>=0; j--) {
            let e = enemies[j];
            if(e.dead || b.hit.includes(e.id)) continue;
            
            // ★高速化: 平方根計算を避ける
            let bulletHitSize = (player.class === 'Sniper' && b.type === 'normal') ? b.size + 15 : b.size;
            if(stats.titan) bulletHitSize *= 1.5;
            let collisionR = bulletHitSize + e.size;
            
            // x, y の差分チェックだけで弾ける場合は弾く（AABB簡易判定）
            if(Math.abs(b.x - e.x) > collisionR || Math.abs(b.y - e.y) > collisionR) continue;

            // 距離の二乗で判定 (sqrtを使わない)
            let distSq = (b.x - e.x)**2 + (b.y - e.y)**2;
            if(distSq < collisionR * collisionR) {

                if(b.type === 'missile') {
                    Sound.play('explode');
                    particles.push({type:'shockwave', x:b.x, y:b.y, size:10, life:15, color:'#f80'});
                    let blastR = 100 * stats.missileBlast;
                    let blastDmg = stats.dmg * 3 * stats.missileBlast;
                    enemies.forEach(subE => { 
                        if(!subE.dead && Math.hypot(subE.x - b.x, subE.y - b.y) < blastR) {
                            damageEnemy(subE, blastDmg);
                            if(stats.napalm && Math.random()<0.5) gasClouds.push({x:subE.x, y:subE.y, r:30, life:120, dmg:stats.dmg*0.2});
                        }
                    });
                    if(particles.length < MAX_PARTICLES) createParticles(b.x, b.y, '#f00', 10 * stats.missileBlast, 5 * stats.missileBlast);
                    bullets.splice(i, 1); hit = true; break;
                } else {
                    let finalDmg = stats.dmg * (b.damageMult || 1);
                    damageEnemy(e, finalDmg);

                    if(stats.coldFlask && Math.random() < 0.1) {
                        e.frozen = 60; 
                        createParticles(e.x, e.y, '#0ff', 5, 2);
                    }
                    if(stats.knockback > 0 && !b.isMini) {
                        let ang = Math.atan2(e.y - player.y, e.x - player.x);
                        e.x += Math.cos(ang) * stats.knockback * 20;
                        e.y += Math.sin(ang) * stats.knockback * 20;
                    }
                    if(stats.clusterStriker && !b.isMini) {
                         Sound.play('explode', 2.0);
                         for(let k=0; k<6; k++) {
                             let ang = (Math.PI*2/6)*k;
                             bullets.push({type:'missile', x:e.x, y:e.y, vx:Math.cos(ang)*5, vy:Math.sin(ang)*5, size:4, speed:0, hit:[e.id], isMini:true});
                         }
                    }
                    if(stats.prismSplit && !b.isMini && (b.splitCount || 0) < 2) {
                        for(let k=0; k<2; k++) {
                             let ang = Math.atan2(b.vy, b.vx) + (k===0 ? 0.5 : -0.5);
                             bullets.push({
                                 type:'normal', x:e.x, y:e.y, 
                                 vx:Math.cos(ang)*stats.bulletSpeed, vy:Math.sin(ang)*stats.bulletSpeed, 
                                 size:b.size*0.8, hit:[e.id], pierce:0, isMini:false, color:'#f0f',
                                 splitCount: (b.splitCount||0)+1
                             });
                        }
                    }
                    if(stats.absoluteZero && Math.random()<0.3) e.frozen = 60; 
                    if(stats.shotExplode) { 
                        Sound.play('explode', 2.0);
                        enemies.forEach(subE => { if(!subE.dead && Math.hypot(subE.x-e.x, subE.y-e.y) < 50) damageEnemy(subE, stats.dmg*0.5); });
                        createParticles(e.x, e.y, '#fa0', 3, 2);
                    }
                    if(stats.napalm && Math.random()<0.2) gasClouds.push({x:e.x, y:e.y, r:20, life:100, dmg:stats.dmg*0.2});
                    
                    if(stats.splitShot && !b.isMini) { 
                        for(let k=0; k<2; k++) {
                            let ang = (Math.random()*Math.PI*2);
                            bullets.push({type:'normal', x:e.x, y:e.y, vx:Math.cos(ang)*10, vy:Math.sin(ang)*10, size:3, hit:[e.id], pierce:0, isMini:true});
                        }
                    }

                    if(stats.lightning > 0) triggerLightning(e, stats.lightning);
                    b.hit.push(e.id);
                    if(particles.length < MAX_PARTICLES) createParticles(b.x, b.y, '#ffffaa', 3, 2); 
                    
                    if(b.pierce <= 0 && !stats.infinitePierce) { bullets.splice(i, 1); hit = true; break; } 
                    else { b.pierce--; }
                }
            }
        }
        if(hit) continue;
    }

    for(let i=enemyBullets.length-1; i>=0; i--) {
        let b = enemyBullets[i];
        b.x += b.vx * ts; b.y += b.vy * ts;
        if(b.x < -100 || b.x > canvas.width+100 || b.y < -100 || b.y > canvas.height+100) { enemyBullets.splice(i, 1); continue; }
        if(Math.hypot(player.x-b.x, player.y-b.y) < player.size + b.size) { 
            let dmg = 10 + Math.floor(level * 0.5);
            takeDamage(dmg); 
            enemyBullets.splice(i, 1); 
        }
    }

    if(enemies.length < MAX_ENEMIES) {
        let spawnDenom = Math.max(5, 25 - (level * 0.6)); 
        let hordeMult = 1.0;
        if (level >= 5) {
            let progress = Math.min(1.0, (level - 5) / 25);
            hordeMult = 2.0 + progress; 
        }
        if (singularityMode) hordeMult *= 3.0;

        let spawnProb = (hordeMult / spawnDenom) * ts;
        if(player.hp >= player.maxHp * 0.9) {
            spawnProb *= 3.0; 
        }

        if(Math.random() < spawnProb) spawnEnemy('random', gameTimeSec);
    }

    let cycleTime = gameTimeSec % 300; 
    let cycleWave = Math.floor(gameTimeSec / 300);

    if(cycleTime > 295 && !bossWarningActive && cycleWave === bossCycleCounter) {
        bossWarningActive = true;
        triggerWarning();
    }
    if(cycleWave > bossCycleCounter) {
        bossCycleCounter = cycleWave;
        bossWarningActive = false;
        document.getElementById('warning-overlay').style.display = 'none';
        spawnEnemy('boss', gameTimeSec); 
    }

    enemies.forEach(e => {
        if(e.dead) return;
        
        if(e.frozen > 0) { 
            e.frozen -= ts;
            if(Math.random()<0.1 && particles.length < MAX_PARTICLES) createParticles(e.x, e.y, '#88ffff', 1, 1);
        } else {
            let dist = Math.hypot(player.x - e.x, player.y - e.y);
            let angle = Math.atan2(player.y - e.y, player.x - e.x);
            if (e.flash > 0) e.flash -= ts;
            
            if(e.ai === 'dasher') {
                if(e.state === 'chase') {
                    e.x += Math.cos(angle) * e.speed * ts; e.y += Math.sin(angle) * e.speed * ts;
                    if(dist < 250) { e.state = 'aim'; e.timer = 30; } 
                } else if(e.state === 'aim') {
                    e.timer -= ts; if(e.timer <= 0) { e.state = 'dash'; e.timer = 30; e.vx = Math.cos(angle) * 14; e.vy = Math.sin(angle) * 14; }
                } else if(e.state === 'dash') {
                    e.x += e.vx * ts; e.y += e.vy * ts; e.timer -= ts; 
                    if(Math.random() < 0.5 * ts && particles.length < MAX_PARTICLES) createParticles(e.x, e.y, '#f80', 1, 2);
                    if(e.timer <= 0) { e.state = 'cooldown'; e.timer = 50; }
                } else if(e.state === 'cooldown') { e.timer -= ts; e.x += Math.cos(angle) * (e.speed * 0.2) * ts; if(e.timer <= 0) e.state = 'chase'; }
            } else if(e.ai === 'shooter') {
                if(dist > 250) { e.x += Math.cos(angle) * e.speed * ts; e.y += Math.sin(angle) * e.speed * ts; }
                else if(dist < 150) { e.x -= Math.cos(angle) * e.speed * 0.5 * ts; e.y -= Math.sin(angle) * e.speed * 0.5 * ts; }
                if(Math.random() < (1/120)*ts && dist < 600) { enemyBullets.push({x: e.x, y: e.y, vx: Math.cos(angle)*6, vy: Math.sin(angle)*6, size: 6, color: '#f0a'}); }
            } else if(e.ai === 'bat') {
                let zig = Math.sin(gameTimeSec * 5) * 0.8;
                e.x += Math.cos(angle + zig) * e.speed * ts; e.y += Math.sin(angle + zig) * e.speed * ts;
            } else {
                e.x += Math.cos(angle) * e.speed * ts; e.y += Math.sin(angle) * e.speed * ts;
            }

            if(dist < player.size + e.size) {
                if(stats.spikeArmor && Math.random() < 0.2 * ts) {
                    damageEnemy(e, stats.dmg * 0.5);
                    if(particles.length < MAX_PARTICLES) createParticles((player.x+e.x)/2, (player.y+e.y)/2, '#fff', 1, 2);
                }
                
                // ★【変更点】反射ダメージを超強化
                if(stats.spikeReflect) { 
                    // 敵の攻撃力の2倍 + 防御力の50倍 を返す
                    let reflectDmg = (e.dmg * 2.0) + (stats.armor * 50);
                    damageEnemy(e, reflectDmg);
                    Sound.play('hit');
                    if(particles.length < MAX_PARTICLES) createParticles(e.x, e.y, '#0f0', 3, 2);
                }

                if(stats.isEarthShaker) {
                    damageEnemy(e, stats.dmg * 2); 
                    Sound.play('bash');
                    let kickAng = Math.atan2(e.y - player.y, e.x - player.x);
                    e.x += Math.cos(kickAng) * 30; e.y += Math.sin(kickAng) * 30;
                }
                
                if(player.class === 'Melee' && player.slamCd <= 0) {
                    let cd = Math.max(10, 60 - stats.rate);
                    player.slamCd = cd; 

                    // ★【変更点】体当たりに最大HP依存ダメージを追加 (MaxHPの20%)
                    let slamBonus = player.maxHp * 0.2; 
                    damageEnemy(e, (stats.dmg * 2) + slamBonus); 

                    let waveSize = 15 + (stats.pierce * 5); 
                    Sound.play('bash');
                    if(particles.length < MAX_PARTICLES) createParticles(e.x, e.y, '#fff', 5, 2);
                    particles.push({type:'shockwave', x:player.x, y:player.y, size:waveSize, life:10, color:'#f00'});
                    
                    // 衝撃波のダメージにもHPボーナスを少し乗せる
                    enemies.forEach(subE => {
                        if(!subE.dead && Math.hypot(subE.x - player.x, subE.y - player.y) < waveSize * 3) {
                            damageEnemy(subE, (stats.dmg * 0.5) + (slamBonus * 0.5));
                        }
                    });
                } else {
                    let contactDmg = e.dmg; 
                    takeDamage(contactDmg);
                }
            }
        }
    });
    
    enemies = enemies.filter(e => !e.dead);

    if(expOrbs.length > MAX_ORBS) {
        let removed = expOrbs.splice(0, expOrbs.length - MAX_ORBS);
        removed.forEach(o => { 
            if(gameActive) {
                addExp(Math.floor(o.val * 0.7), true); 
            }
        });
    }
    for(let i=expOrbs.length-1; i>=0; i--) {
        if(!gameActive) break; 
        let o = expOrbs[i];
        
        let d = Math.hypot(player.x - o.x, player.y - o.y);

        if(o.forceCollect) {
            o.x += (player.x - o.x) * 0.2 * ts; 
            o.y += (player.y - o.y) * 0.2 * ts;
        } else if(d < stats.magnet) {
            o.x += (player.x - o.x) * 0.25 * ts; 
            o.y += (player.y - o.y) * 0.25 * ts; 
        }
        
        if(d < 20) { addExp(o.val); Sound.play('exp', o.pitch); expOrbs.splice(i, 1); }
    }

    for(let i=items.length-1; i>=0; i--) {
        let it = items[i];
        let d = Math.hypot(player.x - it.x, player.y - it.y);
        if(d < 200) {
            it.x += (player.x - it.x) * 0.1 * ts;
            it.y += (player.y - it.y) * 0.1 * ts;
        }
        if(d < 30) {
            if(it.type === 'magnet') {
                Sound.play('powerup');
                particles.push({type:'shockwave', x:player.x, y:player.y, size:500, life:30, color:'#fff'});
                expOrbs.forEach(o => o.forceCollect = true);
            } else if(it.type === 'bomb') {
                triggerBomb();
            }
            items.splice(i, 1);
        }
    }

    if(particles.length > MAX_PARTICLES) particles.splice(0, particles.length - MAX_PARTICLES);
    for(let i=particles.length-1; i>=0; i--) {
        let p = particles[i];
        if(p.type === 'lightning') { p.life -= ts; } 
        else if(p.type === 'shockwave') { p.size += 3 * ts; p.life -= ts; } 
        else { p.x += p.vx * ts; p.y += p.vy * ts; p.life -= ts; p.size *= 0.9; }
        if(p.life <= 0) particles.splice(i, 1);
    }
    
    if(texts.length > MAX_TEXTS) texts.splice(0, texts.length - MAX_TEXTS);
    for(let i=texts.length-1; i>=0; i--) {
        texts[i].y -= 1 * ts; texts[i].life -= ts;
        if(texts[i].life<=0) texts.splice(i, 1);
    }
}

function triggerBomb() {
    Sound.play('bomb');
    let overlay = document.getElementById('bomb-overlay');
    overlay.style.display = 'block';
    overlay.style.opacity = '0.8';
    setTimeout(() => { overlay.style.opacity = '0'; setTimeout(()=>overlay.style.display='none', 500); }, 100);

    enemies.forEach(e => {
        if(!e.dead && e.type !== 'boss') {
            damageEnemy(e, e.hp + 9999);
            createParticles(e.x, e.y, '#fff', 5, 5);
        }
    });
    screenShake = 30;
}

function shoot() {
    // --- 侍 (Samurai) の特殊射撃 ---
    if(stats.samuraiMode) {
        let target = null, minD = Infinity;
        enemies.forEach(e => { if(e.dead) return; let d = Math.hypot(e.x-player.x, e.y-player.y); if(d<minD){minD=d; target=e;} });
        
        let angle = target ? Math.atan2(target.y-player.y, target.x-player.x) : (player.isMoving ? Math.atan2(joyMoveY||0, joyMoveX||1) : -Math.PI/2);
        if(!target && !player.isMoving && joyTouchId === null) angle = -Math.PI/2; 

        // 弾速ステータスを反映
        let slashSpeed = stats.bulletSpeed * 0.9; 
        
        // ★修正1: ここにあった "let bSize = ..." の行を削除しました（エラーの原因になるため）

        Sound.play('missile', 2.0); 
        bullets.push({
            type: 'slash', x: player.x, y: player.y, 
            vx: Math.cos(angle) * slashSpeed, vy: Math.sin(angle) * slashSpeed, 
            angle: angle,
            size: 220 * stats.areaScale, // ここで正しくサイズ倍率を適用しています
            life: 15,  
            color: '#fff', hit: new Set(), pierce: 999, 
            damageMult: 1.0
        });
        
        // 追加効果: 抜刀の衝撃波
        if(stats.swordWave || stats.multi > 1) {
             let waveCount = stats.multi;
             
             let waveDmgMult = 1.0;
             let waveSize = 5 * stats.areaScale; // ★衝撃波にもサイズ適用
             
             if(waveCount > 6) {
                 let extra = waveCount - 6;
                 waveDmgMult += extra * 0.3; 
                 waveSize += Math.min(15, extra * 0.5); 
                 waveCount = 6; 
             }

             for(let i=0; i<waveCount; i++) {
                 let waveAng = angle + (Math.random()-0.5)*0.5;
                 bullets.push({
                    type:'normal', 
                    x:player.x, y:player.y, 
                    vx:Math.cos(waveAng)*stats.bulletSpeed*1.2, 
                    vy:Math.sin(waveAng)*stats.bulletSpeed*1.2, 
                    size:waveSize, 
                    color:'#adf', 
                    pierce:5, 
                    life:40,
                    hit: [],  
                    damageMult: waveDmgMult
                });
             }
        }
        return; 
    }
    // ----------------------------

    let target = null;
    let minD = Infinity;
    
    enemies.forEach(e => {
        if (e.dead) return;
        let d = Math.hypot(e.x - player.x, e.y - player.y);
        if (d < minD) { minD = d; target = e; }
    });

    let angle;
    if (target) { angle = Math.atan2(target.y - player.y, target.x - player.x); } 
    else { angle = Math.random() * Math.PI * 2; }

    let count = stats.multi;
    if(player.class === 'Sniper') count = 1; 
    if(stats.infiniteMag) count += 3; 
    
    let currentDmg = stats.dmg;
    if(stats.siegeMode && stats.isStationary) currentDmg *= 2;
    if(stats.doubleShot && Math.random() < 0.5) count *= 2; 

    let bDmgMultBase = 1.0;
    let bSizeBase = stats.railgun ? 10 : 5;
    
    if(count > 20) {
        let extra = count - 20;
        bDmgMultBase += extra * 0.1; 
        count = 20; 
    }

    let spread = 0.1;
    if(stats.bulletStorm) {
        spread = 0.5 + Math.sin(Date.now()*0.01)*0.5; 
        count += 3; 
    }
    let startAngle = angle - (spread * (count-1)) / 2;

    for(let i=0; i<count; i++) {
        let currentAngle = startAngle + spread * i;
        let vx = Math.cos(currentAngle) * stats.bulletSpeed;
        let vy = Math.sin(currentAngle) * stats.bulletSpeed;
        
        let bType = 'normal';
        let bColor = stats.ghostShot ? '#88ff88' : (stats.prismSplit ? '#f0f' : '#fff');
        let bDmgMult = bDmgMultBase;
        
        // ★修正2: ここで stats.areaScale を掛けて、通常弾も巨大化するように修正
        let bSize = bSizeBase * stats.areaScale; 

        if(stats.tempestMode) {
             bColor = '#d0f'; 
             bSize = 6 * stats.areaScale; // 雷帝の弾にも適用
        }

        if(stats.tricksterMode) {
            let cols = ['#f00', '#0f0', '#00f', '#ff0', '#f0f', '#0ff'];
            bColor = cols[Math.floor(Math.random()*cols.length)];
            if(stats.chaosShot) bSize = (3 + Math.random() * 10) * stats.areaScale;
            let roll = Math.random();
            if(roll < 0.2) stats.pierce = 99; 
            else if(roll < 0.4) stats.homing = 1; 
            else stats.homing = 0;
            if(stats.russianRoulette) {
                if(Math.random() < 0.16) { bDmgMult *= 10; bSize *= 2; bColor='#fff'; } 
                else if(Math.random() < 0.1) { bDmgMult *= 0.1; bSize = 2; bColor='#444'; }
            }
        }

        bullets.push({
            type: bType, x: player.x, y: player.y,
            vx: vx, vy: vy,
            size: bSize, color: bColor,
            hit: [], pierce: stats.pierce,
            damageMult: bDmgMult, isMini: false
        });
    }

    if(stats.doppelganger && player.clone) {
        bullets.push({
            type: 'normal', x: player.clone.x, y: player.clone.y,
            vx: -Math.cos(startAngle)*stats.bulletSpeed, vy: -Math.sin(startAngle)*stats.bulletSpeed,
            size: 5 * stats.areaScale, // 分身の弾にも適用
            color: '#fff', hit: [], pierce: stats.pierce, damageMult: 1, isMini: false
        });
    }

    if(stats.missileChance > 0 && Math.random() < stats.missileChance) fireMissile();
    Sound.play('shoot', 1.0 + Math.random()*0.2);
}

function dash() {
    if(player.dashCd > 0) return;
    player.dashCd = player.maxDashCd;
    player.invincible = 30; // 0.5s invincible
    
    let dx = 0, dy = 0;
    if(keys['w'] || keys['ArrowUp']) dy = -1;
    if(keys['s'] || keys['ArrowDown']) dy = 1;
    if(keys['a'] || keys['ArrowLeft']) dx = -1;
    if(keys['d'] || keys['ArrowRight']) dx = 1;
    
    if(joyTouchId !== null) { dx = joyMoveX; dy = joyMoveY; }
    
    if(dx === 0 && dy === 0) dx = 1; 

    let len = Math.hypot(dx, dy);
    if(len > 0) { dx /= len; dy /= len; }

    player.x += dx * 100;
    player.y += dy * 100;
    player.x = Math.max(15, Math.min(canvas.width-15, player.x));
    player.y = Math.max(15, Math.min(canvas.height-15, player.y));
    
    if(stats.clusterMine) {
         for(let i=0; i<3; i++) {
             let mx = player.x - dx * (20 + i*10);
             let my = player.y - dy * (20 + i*10);
             bullets.push({type:'missile', x:mx, y:my, vx:0, vy:0, speed:0, size:5, hit:[], isMini:false});
         }
    }

    createParticles(player.x, player.y, '#fff', 10, 2);
    Sound.play('dash'); 
}

function spawnSentry() {
    if(sentries.length >= stats.sentryMax) sentries.shift(); // Use max limit
    sentries.push({x: player.x, y: player.y, cooldown: 0});
    createParticles(player.x, player.y, '#0f0', 10, 3);
    Sound.play('spark');
}

function pointToLineDistance(px, py, x1, y1, x2, y2) {
    let A = px - x1; let B = py - y1;
    let C = x2 - x1; let D = y2 - y1;
    let dot = A * C + B * D;
    let len_sq = C * C + D * D;
    let param = -1;
    if (len_sq !== 0) param = dot / len_sq;
    let xx, yy;
    if (param < 0) { xx = x1; yy = y1; }
    else if (param > 1) { xx = x2; yy = y2; }
    else { xx = x1 + param * C; yy = y1 + param * D; }
    let dx = px - xx; let dy = py - yy;
    return Math.hypot(dx, dy);
}

function fireMissile() {
    Sound.play('missile');
    bullets.push({ type: 'missile', x: player.x, y: player.y, vx: (Math.random()-0.5)*4, vy: -5, speed: 10, size: 8, hit: [], isMini: false });
}

function fireOmegaLaser() {
    Sound.play('laser');
    screenShake = 10;
    bullets.push({ type: 'omega', x: player.x, y: player.y, vx: 50, vy: 0, size: 300, life: 30, hit: [], tick: 0 });
    particles.push({type:'shockwave', x:player.x, y:player.y, size:100, life:20, color:'#f0f'});
}

function fireChakram() {
    let ang = Math.random() * Math.PI * 2;
    bullets.push({ 
        type: 'chakram', x: player.x, y: player.y, 
        vx: Math.cos(ang)*12, vy: Math.sin(ang)*12, 
        size: 10 + stats.chakram*2, life: 180 + stats.chakram*30, 
        hit: [], bounceCd: 0 
    });
}

function triggerLightning(target, lv) {
    let range = 200 + (lv * 30); let count = 0; let maxTargets = lv; 
    enemies.forEach(e => {
        if(!e.dead && e !== target && count < maxTargets) {
            if(Math.hypot(e.x - target.x, e.y - target.y) < range) {
                damageEnemy(e, stats.dmg * 0.8);
                createLightningEffect(target.x, target.y, e.x, e.y);
                Sound.play('lightning'); count++;
            }
        }
    });
}
function createLightningEffect(x1, y1, x2, y2) { 
    if(particles.length > MAX_PARTICLES) return;
    particles.push({ type: 'lightning', x1: x1, y1: y1, x2: x2, y2: y2, life: 10, color: '#88ffff' }); 
}

function takeDamage(dmg) {
    if(Math.random() < stats.dodge) {
        // 回避成功！
        if(texts.length < MAX_TEXTS) texts.push({x:player.x, y:player.y-20, str:"MISS", life:30, color:'#88ff88'});
        return; 
    }
    
    if(stats.forceField && stats.forceFieldCd <= 0) {
        stats.forceFieldCd = 300; 
        Sound.play('bounce');
        particles.push({type:'shockwave', x:player.x, y:player.y, size:50, life:20, color:'#0ff'});
        return; 
    }
    
    if(player.invincible > 0) return;
    
    dmg = Math.max(1, dmg - stats.armor);

    player.hp -= dmg; 
    player.invincible = 20; 
    screenShake = 15;
    createParticles(player.x, player.y, '#f00', 10, 4); updateUI();
    
    if(stats.reactiveArmor) {
        Sound.play('spark');
        particles.push({type:'shockwave', x:player.x, y:player.y, size:150, life:10, color:'#0f0'});
        enemies.forEach(e => {
             if(!e.dead && Math.hypot(e.x - player.x, e.y - player.y) < 150) {
                 damageEnemy(e, stats.dmg);
                 let ang = Math.atan2(e.y - player.y, e.x - player.x);
                 e.x += Math.cos(ang) * 50; e.y += Math.sin(ang) * 50; 
             }
        });
    }

    if(player.hp <= 0) gameOver();
}

function draw() {
    let shakeX = (Math.random() - 0.5) * screenShake;
    let shakeY = (Math.random() - 0.5) * screenShake;
    ctx.save(); ctx.translate(shakeX, shakeY);

    ctx.fillStyle = '#050505'; ctx.fillRect(-20, -20, canvas.width+40, canvas.height+40);
    
    ctx.strokeStyle = '#1a1a1a'; ctx.lineWidth = 1; ctx.beginPath();
    for(let i=0; i<canvas.width; i+=100) { ctx.moveTo(i,0); ctx.lineTo(i,canvas.height); }
    for(let i=0; i<canvas.height; i+=100) { ctx.moveTo(0,i); ctx.lineTo(canvas.width,i); }
    ctx.stroke();

    // ★軽量化: 巨大な円などの描画を簡素化（shadowBlur削除など）

    if(stats.absoluteZero) {
        ctx.fillStyle = 'rgba(0, 255, 255, 0.05)';
        ctx.beginPath(); ctx.arc(player.x, player.y, 250, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)'; ctx.lineWidth=1; ctx.stroke();
    }
    if(stats.electroFence) {
        ctx.strokeStyle = `rgba(136, 255, 255, ${(electroFenceTimer/60)})`;
        ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(player.x, player.y, 150, 0, Math.PI*2); ctx.stroke();
    }

    gasClouds.forEach(g => { ctx.fillStyle = `rgba(100, 0, 150, ${g.life/100})`; ctx.beginPath(); ctx.arc(g.x, g.y, g.r, 0, Math.PI*2); ctx.fill(); });

    sentries.forEach(s => {
        ctx.fillStyle = '#0f0'; ctx.fillRect(s.x-10, s.y-10, 20, 20);
        ctx.strokeStyle = '#fff'; ctx.lineWidth=2; ctx.strokeRect(s.x-10, s.y-10, 20, 20);
    });
    if(stats.teslaGrid && sentries.length >= 2) {
        ctx.strokeStyle = '#0ff'; ctx.lineWidth = 3; // shadowBlur削除
        ctx.beginPath();
        ctx.moveTo(sentries[0].x, sentries[0].y);
        for(let i=1; i<sentries.length; i++) ctx.lineTo(sentries[i].x, sentries[i].y);
        ctx.lineTo(sentries[0].x, sentries[0].y);
        ctx.stroke();
    }

    if(player.class === 'Melee' && flyingSwords.length > 0) {
        ctx.fillStyle = '#f0a';
        flyingSwords.forEach(sw => {
            ctx.save(); ctx.translate(sw.x, sw.y); ctx.rotate(Date.now()*0.1);
            ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(5, 5); ctx.lineTo(-5, 5); ctx.fill();
            ctx.restore();
            ctx.strokeStyle = 'rgba(255, 0, 100, 0.3)'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(player.x, player.y); ctx.lineTo(sw.x, sw.y); ctx.stroke();
        });
    }

    if(player.class === 'Melee' && spikeBits.length > 0) {
        ctx.fillStyle = '#f00';
        spikeBits.forEach(bit => {
            ctx.beginPath(); ctx.moveTo(bit.x, bit.y - 8); ctx.lineTo(bit.x + 6, bit.y + 6); ctx.lineTo(bit.x - 6, bit.y + 6); ctx.fill();
        });
    }

    if(stats.aura) {
        ctx.save(); ctx.translate(player.x, player.y); ctx.rotate(Date.now() * 0.005);
        let r = stats.auraRange * stats.auraScale;
        let auraColor = '0, 255, 255';
        if(player.subClass === 'SunCrusher') {
            auraColor = '255, 100, 0'; 
            if(player.isMoving) r += player.sunCharge * 2;
        }

        let grad = ctx.createRadialGradient(0, 0, r*0.5, 0, 0, r);
        grad.addColorStop(0, `rgba(${auraColor}, 0)`); grad.addColorStop(0.8, `rgba(${auraColor}, 0.2)`);
        if(stats.gravityAura) grad.addColorStop(0.9, 'rgba(100, 0, 200, 0.4)'); 
        if(stats.blackHole) { grad.addColorStop(1, 'rgba(0, 0, 0, 0.6)'); ctx.strokeStyle='#f0f'; } 
        else ctx.strokeStyle = `rgba(${auraColor}, 0.5)`;
        
        ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();
        ctx.lineWidth = 2;
        ctx.beginPath(); for(let i=0; i<3; i++) { ctx.rotate(Math.PI*2/3); ctx.moveTo(r * 0.6, 0); ctx.lineTo(r, 0); }
        ctx.stroke(); ctx.restore();
    }

    ctx.fillStyle = '#0ff';
    orbitals.forEach(o => { ctx.beginPath(); ctx.arc(o.x, o.y, 8, 0, Math.PI*2); ctx.fill(); });
    
    drones.forEach(d => {
        ctx.save(); ctx.translate(d.x, d.y); ctx.rotate(Date.now() * 0.01);
        ctx.fillStyle = '#ff0'; ctx.fillRect(-6, -6, 12, 12);
        ctx.strokeStyle = '#fff'; ctx.strokeRect(-6, -6, 12, 12);
        ctx.restore();
    });

    if(stats.forceField && stats.forceFieldCd <= 0) {
        ctx.strokeStyle = `rgba(0, 255, 255, 0.8)`; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(player.x, player.y, player.size + 10, 0, Math.PI*2); ctx.stroke();
    }

    items.forEach(it => {
        ctx.save(); ctx.translate(it.x, it.y);
        let s = 1.0 + Math.sin(Date.now()*0.01)*0.2;
        ctx.scale(s, s);
        ctx.font = '24px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline='middle';
        if(it.type === 'magnet') ctx.fillText('🧲', 0, 0);
        else if(it.type === 'bomb') ctx.fillText('💣', 0, 0);
        ctx.restore();
    });

    if(player.invincible % 10 < 5) {
        // ★軽量化: プレイヤーの影も削除
        ctx.fillStyle = player.color;
        ctx.beginPath(); ctx.arc(player.x, player.y, player.size, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(player.x, player.y, player.size*0.6, 0, Math.PI*2); ctx.fill(); 
    }

    bullets.forEach(b => { 
        if(b.type === 'slash') {
            ctx.save();
            ctx.translate(b.x, b.y);
            ctx.rotate(b.angle);
            ctx.globalAlpha = Math.max(0, b.life / 15); 
            
            ctx.fillStyle = '#fff';
            // ★軽量化: 斬撃の影も削除
            ctx.beginPath();
            ctx.arc(0, 0, b.size, -Math.PI/1.8, Math.PI/1.8); 
            ctx.fill();

            ctx.strokeStyle = '#ccffff'; ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(0, 0); ctx.lineTo(b.size + 20, 0);
            ctx.stroke();
            
            ctx.restore();
            return;
        }

        if(b.type === 'omega') {
            ctx.fillStyle = `rgba(255, 0, 255, ${b.life/30})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff'; ctx.fillRect(0, b.y - 50, canvas.width, 100);
        }
        else if(b.type === 'missile') {
            ctx.fillStyle = '#f80'; ctx.beginPath(); ctx.moveTo(b.x, b.y-8); ctx.lineTo(b.x+6, b.y+6); ctx.lineTo(b.x-6, b.y+6); ctx.fill();
        } else if(b.type === 'chakram') {
            ctx.fillStyle = '#0ff'; ctx.save(); ctx.translate(b.x, b.y); ctx.rotate(Date.now() * 0.2);
            ctx.fillRect(-b.size/2, -b.size/2, b.size, b.size); ctx.restore();
        } else if(b.type === 'spirit') {
            ctx.fillStyle = '#8f8'; ctx.beginPath(); ctx.arc(b.x, b.y, 6, 0, Math.PI*2); ctx.fill();
        } else {
            let drawSize = (player.class === 'Sniper' && b.type === 'normal') ? 8 : b.size;
            if(b.isMini) drawSize = 2;
            ctx.fillStyle = b.color; ctx.beginPath(); ctx.arc(b.x, b.y, drawSize, 0, Math.PI*2); ctx.fill(); 
        }
    });
    
    // ★軽量化: 敵弾の影削除
    ctx.fillStyle = '#fff'; 
    enemyBullets.forEach(b => { ctx.beginPath(); ctx.arc(b.x, b.y, b.size, 0, Math.PI*2); ctx.fill(); });

    enemies.forEach(e => {
        ctx.fillStyle = e.frozen > 0 ? '#0ff' : (e.flash > 0 ? '#fff' : e.color); 
        ctx.beginPath();
        if(e.type === 'boss') {
            // ボスだけは特別なので影を残しても良いが、軽量化優先で削除
            ctx.fillRect(e.x-e.size, e.y-e.size, e.size*2, e.size*2);
            ctx.fillStyle = 'red'; ctx.fillRect(e.x-40, e.y-e.size-20, 80, 8); ctx.fillStyle = '#0f0'; ctx.fillRect(e.x-40, e.y-e.size-20, 80*(e.hp/e.maxHp), 8);
        } else if(e.type === 'golem') {
            ctx.fillRect(e.x-e.size, e.y-e.size, e.size*2, e.size*2);
            ctx.strokeStyle = '#000'; ctx.lineWidth = 2; ctx.strokeRect(e.x-e.size, e.y-e.size, e.size*2, e.size*2);
        } else {
            if(e.ai === 'dasher') { ctx.moveTo(e.x, e.y-e.size); ctx.lineTo(e.x+e.size, e.y+e.size); ctx.lineTo(e.x-e.size, e.y+e.size); ctx.closePath(); }
            else if(e.ai === 'splitter') { ctx.rect(e.x-e.size, e.y-e.size, e.size*2, e.size*2); }
            else if(e.ai === 'bat') { ctx.moveTo(e.x, e.y-e.size); ctx.lineTo(e.x+e.size, e.y); ctx.lineTo(e.x, e.y+e.size); ctx.lineTo(e.x-e.size, e.y); ctx.closePath(); }
            else if(e.ai === 'shooter') { ctx.rect(e.x-e.size, e.y-e.size, e.size*2, e.size*2); }
            else if(e.ai === 'tank') { for(let i=0; i<6; i++) { let ang = i * Math.PI / 3; let px = e.x + Math.cos(ang) * e.size; let py = e.y + Math.sin(ang) * e.size; if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py); } ctx.closePath(); }
            else { ctx.arc(e.x, e.y, e.size, 0, Math.PI*2); }
            ctx.fill();
        }
    });

    expOrbs.forEach(o => { ctx.fillStyle = o.color; ctx.beginPath(); ctx.arc(o.x, o.y, o.size, 0, Math.PI*2); ctx.fill(); });
    
    particles.forEach(p => {
        if(p.type === 'lightning') {
            ctx.strokeStyle = p.color; ctx.lineWidth = 3; ctx.globalAlpha = p.life / 10; // shadowBlur削除
            ctx.beginPath(); ctx.moveTo(p.x1, p.y1);
            let midX = (p.x1 + p.x2) / 2 + (Math.random()-0.5)*30; let midY = (p.y1 + p.y2) / 2 + (Math.random()-0.5)*30;
            ctx.lineTo(midX, midY); ctx.lineTo(p.x2, p.y2); ctx.stroke(); ctx.globalAlpha = 1.0; 
        } else if(p.type === 'shockwave') {
            ctx.strokeStyle = p.color; ctx.lineWidth = 3; ctx.globalAlpha = p.life/15;
            ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.stroke(); ctx.globalAlpha=1;
        } else {
            ctx.fillStyle = p.color; ctx.globalAlpha = p.life / 20; ctx.fillRect(p.x, p.y, p.size, p.size); ctx.globalAlpha = 1.0;
        }
    });

    ctx.font = 'bold 16px sans-serif';
    texts.forEach(t => { ctx.fillStyle = t.color || 'white'; ctx.fillText(t.str, t.x, t.y); });

    ctx.restore();
    let grad = ctx.createRadialGradient(player.x, player.y, 100, player.x, player.y, 800);
    grad.addColorStop(0, 'rgba(0,0,0,0)'); grad.addColorStop(1, 'rgba(0,0,0,0.6)');
    ctx.fillStyle = grad; ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function spawnEnemy(mode, time) {
    if(enemies.length >= MAX_ENEMIES && mode !== 'boss') return; 

    let dist = Math.max(canvas.width, canvas.height)/2 + 50;
    let ang = Math.random()*Math.PI*2;
    let ex = player.x + Math.cos(ang)*dist; let ey = player.y + Math.sin(ang)*dist; let type = mode;
    if(mode === 'random') {
        let r = Math.random();
        
        // ★ Golem Spawn Logic
        let canGolem = level >= 50;
        
        let canSplitter = time > 45; let canBat = time > 90; let canDasher = time > 120; let canShooter = time > 150; let canTank = time > 180;
        
        if(canGolem && r < 0.08) type = 'golem'; 
        else if(canTank && r < 0.15) type = 'tank'; 
        else if(canShooter && r < 0.25) type = 'shooter'; 
        else if(canDasher && r < 0.35) type = 'dasher'; 
        else if(canSplitter && r < 0.45) type = 'splitter'; 
        else if(canBat && r < 0.6) type = 'bat'; 
        else type = 'normal';
    }
    createEnemy(type, ex, ey);
}

function createEnemy(type, x, y) {
    let e = { id: Math.random(), x: x, y: y, flash: 0, type: 'mob', frozen: 0 };
    
    let hpMult = Math.pow(1.10, level - 1); 
    if(singularityMode) hpMult *= 2.0;

    // ▼▼▼ ここを修正（大きいレベルから順に判定します） ▼▼▼
    if (player.hp >= player.maxHp * 0.9) {
        if (level >= 60) {
            hpMult *= 8.0; // Lv50以上なら10倍！
        } else if (level >= 40) {
            hpMult *= 5.0;  // Lv40～49なら5倍
        }
    }
    // ▲▲▲ 修正終わり ▲▲▲

    if(type === 'boss') { 
        e.hp = 3000 * hpMult; e.maxHp = e.hp; e.size = 90; e.color = '#cc0000'; e.speed = 2.5 + (level * 0.02); e.ai='boss'; e.type='boss'; 
        e.hp *= (1 + bossCycleCounter * 0.3); 
        e.dmg = 50 + (level * 2);
    }
    else if(type === 'golem') {
        e.hp = 450 * hpMult; e.maxHp = e.hp; 
        e.size = 25; e.color = '#2F4F4F'; 
        e.speed = (2.0 + (level * 0.01)) * 0.3; 
        e.ai = 'normal'; e.type = 'golem';
    }
    else if(type === 'dasher') { e.hp = 25 * hpMult; e.maxHp = e.hp; e.size = 18; e.color = '#ff3333'; e.speed = 2.5 + (level * 0.02); e.ai='dasher'; e.state='chase'; }
    else if(type === 'splitter') { e.hp = 20 * hpMult; e.maxHp = e.hp; e.size = 20; e.color = '#ff3333'; e.speed = 1.2 + (level * 0.01); e.ai='splitter'; }
    else if(type === 'bat') { e.hp = 8 * hpMult; e.maxHp = e.hp; e.size = 10; e.color = '#ff3333'; e.speed = 5.0 + (level * 0.03); e.ai='bat'; }
    else if(type === 'shooter') { e.hp = 22 * hpMult; e.maxHp = e.hp; e.size = 15; e.color = '#ff3333'; e.speed = 1.8 + (level * 0.01); e.ai='shooter'; }
    else if(type === 'tank') { e.hp = 80 * hpMult; e.maxHp = e.hp; e.size = 24; e.color = '#ff3333'; e.speed = 1.0 + (level * 0.01); e.ai='tank'; }
    else if(type === 'minion') { e.hp = 8 * hpMult; e.maxHp = e.hp; e.size = 10; e.color = '#ff3333'; e.speed = 3.0 + (level * 0.02); e.ai='normal'; }
    else { e.hp = 15 * hpMult; e.maxHp = e.hp; e.size = 14; e.color = '#ff3333'; e.speed = 2.0 + (level * 0.01) + Math.random(); e.ai='normal'; }
    
    if(!e.dmg) e.dmg = 10 + Math.floor(level * 1.5);
    
    if(singularityMode) { e.color = '#000000'; e.speed *= 1.2; }

    enemies.push(e);
}

function damageEnemy(e, dmg) {
    if(e.dead) return; 
    
    // ガーディアンの固定砲台ボーナス
    if(stats.siegeMode && stats.isStationary) dmg *= 2;

    // --- ★変更点1：クリティカル計算の強化 ---
    let isCrit = false;
    if(Math.random() < stats.critChance || stats.deadeye) { 
        // 以前の「3倍か2倍」という固定値ではなく、育てた stats.critMult を使う
        let multiplier = stats.deadeye ? (stats.critMult + 1.0) : stats.critMult;
        dmg *= multiplier; 
        isCrit = true; 
    } 
    
    // 既存スキル：ジャイアントスレイヤー
    if(stats.giantSlayer && (e.type === 'boss' || e.ai === 'tank')) dmg *= 2;
    // 既存スキル：処刑人
    if(stats.executioner && (e.hp < e.maxHp * 0.2)) dmg = e.hp + 999; 
    if(stats.execute && (e.hp < e.maxHp * 0.3)) dmg = e.hp + 9999; 

    // --- ★変更点2：敵HPに応じた割合ダメージ追加（ジャイアントキラー） ---
    if(stats.hpDamage > 0) {
        // ボス相手だと強すぎる場合があるので、最大でも「基本ダメージの50倍」までに制限する安全策付き
        let percentDmg = e.maxHp * stats.hpDamage;
        let cap = stats.dmg * 50; 
        dmg += Math.min(percentDmg, cap);
    }

    // --- ★変更点3：背水ダメージ（鮮血の爪） ---
    if(stats.lowHpDmg) {
        // HPが減っている割合（0.0 ～ 1.0）
        let lostHpRatio = 1.0 - (player.hp / player.maxHp);
        // ダメージ倍率計算（最大3倍）
        dmg *= (1.0 + lostHpRatio * 2.0);
        
        // 演出：威力が上がっているときはダメージ数字を赤くするなどの処理を入れると分かりやすい
        if(lostHpRatio > 0.5) isCrit = true; // 演出用
    }

    // --- ここから下は変更なし ---
    e.hp -= dmg; e.flash = 5; 
    
    if(particles.length < MAX_PARTICLES && Math.random() < 0.2) createParticles(e.x, e.y, '#fff', 1, 2); 
    Sound.play('hit');

    if(isCrit || e.type === 'boss' || texts.length < 5 || Math.random() < 0.2) {
        if(texts.length < MAX_TEXTS) texts.push({x:e.x, y:e.y, str:Math.floor(dmg), life:20, color: isCrit?'#ff0':'#fff'});
    }
    
    if(e.hp <= 0) {
        e.dead = true; 
        Sound.play('explode'); 
        screenShake = e.type === 'boss' ? 20 : 2; 

        if(stats.chainBurst) {
             Sound.play('explode', 2.0);
             let range = 100;
             let burstDmg = stats.dmg * 2;
             if(Math.random() < 0.3) createParticles(e.x, e.y, '#0ff', 5, 3);
             enemies.forEach(subE => {
                 if(!subE.dead && Math.hypot(subE.x-e.x, subE.y-e.y) < range) {
                     damageEnemy(subE, burstDmg);
                 }
             });
        }

        if(stats.shrapnel) {
            for(let i=0; i<3; i++) {
                let ang = Math.random() * Math.PI * 2;
                bullets.push({type:'normal', x:e.x, y:e.y, vx:Math.cos(ang)*8, vy:Math.sin(ang)*8, size:3, hit:[e.id], pierce:1, isMini:true, life:15});
            }
        }

        if(stats.necromancer) {
            bullets.push({type: 'spirit', x: e.x, y: e.y, vx: 0, vy: 0, speed: 8, size: 6, hit: [], isMini: false});
        }
        if(stats.bloodLust) { 
             player.hp = Math.min(player.maxHp, player.hp + player.maxHp * 0.01);
        }

        if(stats.jackpot && Math.random() < 0.05) { 
             Sound.play('levelup');
             for(let k=0; k<5; k++) {
                 let angle = Math.random() * Math.PI * 2;
                 let dist = Math.random() * 30;
                 expOrbs.push({x: e.x + Math.cos(angle)*dist, y: e.y + Math.sin(angle)*dist, size: 8, val: 100, color: '#ffd700', pitch: 1.5});
             }
             texts.push({x:e.x, y:e.y, str:"JACKPOT!", life:60, color:'#ffd700'});
        }

        if(stats.lifesteal > 0) { player.hp = Math.min(player.maxHp, player.hp + stats.lifesteal); updateUI(); }
        
        if(particles.length < MAX_PARTICLES) createParticles(e.x, e.y, e.color, e.type==='boss'?30:3, 4);

        let levelScaler = 1 + (level * 0.5); 
        if(singularityMode) levelScaler *= 2;
        let baseVal = 25 * levelScaler;
        let val = baseVal;
        if(e.type === 'boss') val = baseVal * 50;
        else if(e.ai === 'tank') val = Math.max(300, baseVal * 3);

        let orbType = { val: val, color: '#0ff', size: 4, pitch: 1.0 }; 
        if(val >= 20000) orbType = { val: val, color: '#f0f', size: 16, pitch: 0.5 }; 
        else if(val >= 6000) orbType = { val: val, color: '#f00', size: 14, pitch: 0.6 }; 
        else if(val >= 1500) orbType = { val: val, color: '#f80', size: 12, pitch: 0.7 }; 
        else if(val >= 300) orbType = { val: val, color: '#00f', size: 10, pitch: 0.8 }; 
        else if(val >= 80) orbType = { val: val, color: '#0f0', size: 8, pitch: 0.9 }; 
        
        if(e.ai === 'splitter') { createEnemy('minion', e.x+10, e.y); createEnemy('minion', e.x-10, e.y); }
        score += val; updateUI(); 
        
        expOrbs.push({x: e.x, y: e.y, size: orbType.size, val: orbType.val, color: orbType.color, pitch: orbType.pitch});

        if(Math.random() < 0.002) items.push({type: 'magnet', x: e.x, y: e.y});
        if(Math.random() < 0.0005) items.push({type: 'bomb', x: e.x, y: e.y});
    }
}

function addExp(v, silent) {
    if(!gameActive) return; 
    exp += v; 
    if(exp >= nextExp) { 
        exp = 0; level++; 
        if (level < 45) {
            // Lv50までは今まで通り（ハイペース）
            nextExp = Math.floor(nextExp * 1.15) + 500;
        } else {
            // Lv50以降は伸びを緩やかにする（15%増 → 2%増にダウン）
            // これでLv50以降も、今までよりずっと早くレベルが上がります
            nextExp = Math.floor(nextExp * 1.02) + 1000;
        }
        Sound.play('levelup'); updateUI(); 
        
        if(level === 5) showEvo(); 
        else if(level === 40) showSecondEvo(); // ★ 2nd Evolution Trigger
        else if(level >= 20 && level % 10 === 0) showMilestone(); 
        else showUpgrade(); 
    }
    document.getElementById('xp-fill').style.width = Math.min(100, (exp/nextExp*100))+'%';
}

// ★ New Second Evolution Function
function showSecondEvo() {
    gameActive = false;
    let m = document.getElementById('menu-overlay'); let c = document.getElementById('card-area');
    c.innerHTML = ''; m.style.display = 'flex';
    document.querySelector('#menu-title').innerText = "第2次進化 (Class Evolution)";

    let evos = [];

    // --- ⚔️ 侍 (Samurai) の進化 ---
    if(player.class === 'Samurai') {
        evos = [
            {t:"👹 阿修羅 (Ashura)", d:"乱舞: 攻撃速度が極限まで上昇し、目にも止まらぬ連続斬りを繰り出す。", f:()=>{
                player.subClass = 'Ashura';
                stats.rate = 15; // 攻撃間隔を短縮（高速化）
                stats.dmg *= 0.8; // 単発威力は少し下がる
                player.color = "#ff0033"; // 深紅
            }},
            {t:"🌀 剣聖 (Kensei)", d:"真空波: 斬撃と同時に、遠くまで飛ぶ鋭い衝撃波を放つ。", f:()=>{
                player.subClass = 'Kensei';
                stats.swordWave = true; // 衝撃波フラグ
                stats.dmg *= 1.5; // 威力アップ
                player.color = "#ccccff"; // 青白
            }}
        ];
    }
    // --- ⚡ 雷帝 (Tempest) の進化 ---
    else if(player.class === 'Tempest') {
        evos = [
            {t:"⛈️ トール (Thor)", d:"雷神: 落雷の同時攻撃数が劇的に増え、画面全体を焼き払う。", f:()=>{
                player.subClass = 'Thor';
                stats.lightning += 5; // 同時落雷数+5
                stats.lightningDmgMult = 2.0; // 雷ダメージ倍増（要ロジック対応、今回は簡易的にdmg依存）
                player.color = "#ffff00"; 
            }},
            {t:"⚛️ プラズマロード (Plasma)", d:"球状稲妻: 弾が「超低速で進みながら周囲を感電させる球体」に変化する。", f:()=>{
                player.subClass = 'PlasmaLord';
                stats.bulletSpeed = 3; // 超低速
                stats.pierce = 999;    // 無限貫通
                stats.dmg *= 2.0;      // 高威力
                player.size = 20;
                player.color = "#aa00ff";
            }}
        ];
    }
    // --- ⚗️ アルケミスト (Alchemist) の進化 ---
    else if(player.class === 'Alchemist') {
        evos = [
            {t:"🧟 ネクロトキシコロジスト", d:"死者蘇生: 毒で倒した敵が高確率で味方のゾンビとして蘇る。", f:()=>{
                player.subClass = 'NecroToxin';
                stats.zombieVirus = true; 
                player.color = "#00ff00";
            }},
            {t:"💥 マッドサイエンティスト", d:"連鎖爆発: 毒ガスが引火性になり、攻撃を当てると大爆発を起こす。", f:()=>{
                player.subClass = 'MadScientist';
                stats.chemicalBurn = true;
                stats.dmg *= 1.5;
                player.color = "#ff00ff";
            }}
        ];
    }
    // --- 🃏 トリックスター (Trickster) の進化 ---
    else if(player.class === 'Trickster') {
        evos = [
            {t:"🎰 ギャンブラー", d:"ジャックポット: 敵撃破時の経験値獲得量が稀に100倍になる。", f:()=>{
                player.subClass = 'Gambler';
                stats.jackpotChance = 0.1; // 確率アップ
                player.color = "#ffd700";
            }},
            {t:"🃏 ジョーカー", d:"ワイルドカード: 全クラスの最強スキルがランダムで発動する。", f:()=>{
                player.subClass = 'JokerMaster';
                stats.wildCard = true;
                player.color = "#ffffff";
            }}
        ];
    }
    // --- 既存クラス (Assault, Melee, Sniper, Guardian) ---
    else if(player.class === 'Assault') {
        evos = [
            {t:"💥 クラスター・ストライカー", d:"爆発特化: 着弾時に「子爆弾」が周囲に飛び散り、誘爆連鎖を引き起こす。", f:()=>{
                player.subClass = 'ClusterStriker';
                stats.clusterStriker = true;
                stats.dmg *= 1.2;
                player.color = "#ff8800";
            }},
            {t:"🌪️ バレット・ストーム", d:"弾幕特化: 攻撃中、連射速度と拡散範囲が無限に上昇する。画面を埋め尽くせ！", f:()=>{
                player.subClass = 'BulletStorm';
                stats.bulletStorm = true;
                player.color = "#0088ff";
            }}
        ];
    } else if(player.class === 'Melee') {
        evos = [
            {t:"🗡️ 御剣 (Flying Swords)", d:"遠隔斬撃: 回転刃がプレイヤーから離れ、自律して敵を追尾・切り刻む。", f:()=>{
                player.subClass = 'FlyingSwords';
                player.color = "#ff0066";
            }},
            {t:"☀️ サン・クラッシャー", d:"灼熱領域: 停止中にエネルギー充填。移動開始時に超広範囲の爆熱波を放つ。", f:()=>{
                player.subClass = 'SunCrusher';
                stats.auraRange += 50;
                player.color = "#ffd700";
            }}
        ];
    } else if(player.class === 'Sniper') {
        evos = [
            {t:"🌌 ディメンション・ウォーカー", d:"次元干渉: 弾が画面端をループする度、巨大化し威力が倍増する。", f:()=>{
                player.subClass = 'DimensionWalker';
                stats.ghostShot = true;
                stats.infinitePierce = true;
                player.color = "#88ff88";
            }},
            {t:"💎 プリズム・シューター", d:"幾何学反射: 弾が敵や壁に当たるたびに2つに分裂し、レーザー網を形成する。", f:()=>{
                player.subClass = 'PrismShooter';
                stats.prismSplit = true;
                stats.dmg *= 0.8; // Balance
                player.color = "#ff00ff";
            }}
        ];
    } else if(player.class === 'Guardian') {
        evos = [
            {t:"⚡ テスラ・エンジニア", d:"電気柵: 設置したタレット同士が「高圧電流」で接続され、触れた敵を焼き尽くす。", f:()=>{
                player.subClass = 'TeslaEngineer';
                stats.teslaGrid = true;
                stats.sentryMax = 12; // さらに増える
                player.color = "#00ffcc";
            }},
            {t:"🦍 アース・シェイカー", d:"重戦車: 巨大化し、歩くだけで足元に衝撃波が発生。敵を弾き飛ばし粉砕する。", f:()=>{
                player.subClass = 'EarthShaker';
                stats.isEarthShaker = true;
                player.size = 30; // Huge
                player.maxHp += 1000; player.hp += 1000;
                stats.armor += 10;
                player.color = "#885500";
            }}
        ];
    }

    // 選択肢生成処理
    if(evos.length > 0) {
        evos.forEach(o => {
            let el = document.createElement('div'); el.className='card evo';
            let icon = o.t.split(' ')[0]; let title = o.t.split(' ').slice(1).join(' ');
            el.innerHTML = `<span class="icon">${icon}</span><h3>${title}</h3><p>${o.d}</p>`;
            el.onclick = () => { 
                o.f(); 
                let nameSpan = document.getElementById('disp-class-name');
                nameSpan.innerText = `(${title})`;
                nameSpan.style.color = player.color;
                resume(); 
            };
            c.appendChild(el);
        });
    } else {
        // 万が一クラスが見つからない場合のフォールバック（バグ回避）
        let el = document.createElement('div'); el.className='card milestone';
        el.innerHTML = `<h3>LIMIT BREAK</h3><p>全ステータス強化</p>`;
        el.onclick = () => { stats.dmg*=1.5; stats.hp+=100; resume(); };
        c.appendChild(el);
    }
}

function showMilestone() {
    gameActive = false;
    Sound.play('milestone');
    let m = document.getElementById('menu-overlay'); let c = document.getElementById('card-area');
    c.innerHTML = ''; m.style.display = 'flex';
    document.querySelector('#menu-title').innerText = "禁断の力 (Lv"+level+")";

    // ★ 定義に 'check' を追加: これが true を返すとリストに出現しなくなります
    
    // --- 共通 (Common) ---
    let pool = [
        {t:"⚡ オメガ・レーザー", d:"3秒ごとに画面を薙ぎ払う極太レーザーを発射。", f:()=>{stats.omegaLaser=true;}, check:()=>stats.omegaLaser},
        {t:"❄️ アブソリュート・ゼロ", d:"周囲の敵を凍結させ、長時間停止させるオーラ。", f:()=>{stats.absoluteZero=true;}, check:()=>stats.absoluteZero}, 
        {t:"💀 ネクロマンサー", d:"敵撃破時に、敵を追尾する怨霊弾を召喚する。", f:()=>{stats.necromancer=true;}, check:()=>stats.necromancer},
        {t:"🩸 血の契約", d:"最大HPが1になる代わりに、攻撃力が5倍になる。", f:()=>{player.maxHp=1; player.hp=1; stats.dmg*=5;}, check:()=>player.maxHp===1},
        {t:"🛡️ ゴッドモード", d:"被弾時の無敵時間が3倍になる。", f:()=>{player.invincibleMax=60;}, check:()=>player.invincibleMax>=60},
        // ▼ 新規追加
        {t:"👥 ドッペルゲンガー", d:"背後に分身が出現し、反対方向へ同時に攻撃する。", f:()=>{stats.doppelganger=true;}, check:()=>stats.doppelganger},
        {t:"⏳ ザ・ワールド", d:"ダメージを受けると時が止まり、回避のチャンスを得る(CDあり)。", f:()=>{stats.timeStop=true;}, check:()=>stats.timeStop},
        {
        t:"🧬 ジャイアントキラー", 
        d:"攻撃時、敵の最大HPの2%分の追加ダメージを与える。", 
        f:()=>{ stats.hpDamage += 0.02; }, 
        check:()=>false // 何度でも取得可能にするなら false、1回限りなら stats.hpDamage > 0
    },
    {
        t:"🎯 フェイタル・クリティカル", 
        d:"クリティカルダメージ倍率 +50% (現在: " + (stats.critMult*100).toFixed(0) + "%)", 
        f:()=>{ stats.critMult += 0.5; }, 
        check:()=>stats.critMult >= 10.0 // 上限を設ける場合
    },
    {
        t:"🩸 鮮血の爪", 
        d:"失ったHP割合に応じて攻撃力が上昇する (背水)", 
        f:()=>{ stats.lowHpDmg = true; }, 
        check:()=>stats.lowHpDmg
    }
    ];

    // --- クラス別 (Class Specific) ---
    if(player.class === 'Assault') {
        pool = pool.concat([
            {t:"💣 爆裂弾", d:"全ての通常弾が着弾時に爆発するようになる。", f:()=>{stats.shotExplode=true;}, check:()=>stats.shotExplode},
            {t:"↩️ 跳弾", d:"弾が画面端で跳ね返るようになる。", f:()=>{stats.shotBounce=true;}, check:()=>stats.shotBounce},
            {t:"👯 ダブルトリガー", d:"50%の確率で、一度に2発の弾を発射する。", f:()=>{stats.doubleShot=true;}, check:()=>stats.doubleShot},
            {t:"🚀 ミサイル祭", d:"射撃時に20%の確率で追加ミサイルを発射。", f:()=>{stats.missileChance=0.2;}, check:()=>stats.missileChance>=0.2},
            {t:"♾️ 無限マガジン", d:"一度の発射数+3。リロード時間がゼロになる。", f:()=>{stats.infiniteMag=true;}, check:()=>stats.infiniteMag},
            {t:"⚙️ ガトリング", d:"連射速度が限界突破し、凄まじい弾幕を張る。", f:()=>{stats.rate=Math.max(1, stats.rate-10); stats.gatling=true;}, check:()=>stats.gatling},
            // ▼ 新規追加
            {t:"🔥 オーバーヒート", d:"撃ち続けると連射速度が上がるが、自分が僅かにダメージを受ける。", f:()=>{stats.overheat=true;}, check:()=>stats.overheat},
            {t:"🦶 リコイルジャンプ", d:"射撃の反動で後ろに下がるようになり、機動力が上がる。", f:()=>{stats.recoilJump=true;}, check:()=>stats.recoilJump}
        ]);
    } else if(player.class === 'Melee') {
        pool = pool.concat([
            {t:"🦍 タイタン", d:"HP2倍、サイズ1.5倍。攻撃判定も巨大化。", f:()=>{player.maxHp*=2; player.hp*=2; player.size*=1.5; stats.titan=true;}, check:()=>stats.titan},
            {t:"⚫ ブラックホール", d:"オーラが敵を強力に吸い寄せるようになる。", f:()=>{stats.blackHole=true;}, check:()=>stats.blackHole},
            {t:"⚔️ ブレードストーム", d:"回転刃の枚数が+4枚追加される。", f:()=>{stats.bladeStorm=true;}, check:()=>stats.bladeStorm},
            {t:"🌎 アースクエイク", d:"2秒ごとに画面全体攻撃を行い、敵を気絶させる。", f:()=>{stats.earthquake=true;}, check:()=>stats.earthquake},
            {t:"🌵 スパイクリフレクト", d:"敵接触時のダメージを2倍にして反射する。", f:()=>{stats.spikeReflect=true;}, check:()=>stats.spikeReflect},
            {t:"🧛 ブラッドラスト", d:"敵を倒すとHPが1%回復する。", f:()=>{stats.bloodLust=true;}, check:()=>stats.bloodLust},
            // ▼ 新規追加
            {t:"🤺 パリィ", d:"15%の確率でダメージを無効化し、周囲を吹き飛ばす。", f:()=>{stats.parry=true;}, check:()=>stats.parry},
            {t:"🌊 ソードウェーブ", d:"回転刃から定期的に真空波が飛び、遠くの敵を斬る。", f:()=>{stats.swordWave=true;}, check:()=>stats.swordWave}
        ]);
    } else if(player.class === 'Sniper') {
        pool = pool.concat([
            {t:"🚅 レールガン", d:"弾速2倍、サイズ2倍。全ての敵を貫通する。", f:()=>{stats.bulletSpeed*=2; stats.railgun=true; stats.infinitePierce=true;}, check:()=>stats.railgun},
            {t:"🔪 処刑人", d:"HP30%以下の敵に攻撃すると即死させる。", f:()=>{stats.execute=true;}, check:()=>stats.execute},
            {t:"👁️ デッドアイ", d:"全ての攻撃がクリティカル(3倍ダメージ)になる。", f:()=>{stats.deadeye=true;}, check:()=>stats.deadeye},
            {t:"⚡ エレクトロフェンス", d:"周囲の敵を麻痺させ、弾き飛ばす電気柵を展開。", f:()=>{stats.electroFence=true;}, check:()=>stats.electroFence}, 
            {t:"💥 チェーンバースト", d:"敵を倒すと連鎖爆発が発生し、周囲を巻き込む。", f:()=>{stats.chainBurst=true;}, check:()=>stats.chainBurst}, 
            {t:"☄️ 天罰", d:"ランダムな位置に強力な衛星レーザーが降り注ぐ。", f:()=>{stats.orbital=true;}, check:()=>stats.orbital},
            // ▼ 新規追加
            {t:"👻 ファントムバレット", d:"壁や敵をすり抜け、画面外から戻ってくる魔法の弾丸。", f:()=>{stats.phantom=true; stats.ghostShot=true;}, check:()=>stats.phantom},
            {t:"🎯 サーマルスコープ", d:"画面外の敵にもホーミングが適用され、クリティカル率が上がる。", f:()=>{stats.thermal=true; stats.homing+=2;}, check:()=>stats.thermal}
        ]);
    } else if(player.class === 'Guardian') {
        pool = pool.concat([
            {t:"🏗️ セントリーシステム", d:"10秒ごとに自動攻撃タレットを設置する。", f:()=>{stats.sentrySystem=true; spawnSentry();}, check:()=>stats.sentrySystem},
            {t:"🏯 シージモード", d:"立ち止まっている間、攻撃速度とダメージが2倍。", f:()=>{stats.siegeMode=true;}, check:()=>stats.siegeMode},
            {t:"⚡ リアクティブアーマー", d:"ダメージを受けると、周囲に電撃カウンターを放つ。", f:()=>{stats.reactiveArmor=true;}, check:()=>stats.reactiveArmor},
            {t:"❤️ ナノマシン修復", d:"HPが30%以下になると超高速で自然回復する。", f:()=>{stats.nanoRepair=true;}, check:()=>stats.nanoRepair},
            {t:"💣 クラスターマイン", d:"ダッシュ時に大量の地雷をばら撒く。", f:()=>{stats.clusterMine=true;}, check:()=>stats.clusterMine},
            {t:"🛡️ フォースフィールド", d:"定期的にダメージを完全無効化するバリアを展開。", f:()=>{stats.forceField=true;}, check:()=>stats.forceField},
            // ▼ 新規追加
            {t:"🚁 護衛ドローン", d:"プレイヤーの周囲を旋回し、近づく敵を迎撃するドローンを配備。", f:()=>{stats.guardDrone=true;}, check:()=>stats.guardDrone},
            {t:"🏰 移動要塞", d:"移動速度が半減する代わりに、防御力とHPが大幅に上昇する。", f:()=>{stats.spd*=0.5; stats.armor+=10; player.maxHp+=500; player.hp+=500;}, check:()=>stats.armor>=25} // 簡易判定
        ]);
    } else if(player.class === 'Alchemist') {
        pool = pool.concat([
            {t:"☣️ パンデミック", d:"毒を受けた敵が死ぬと、その場に毒ガスを発生させる。", f:()=>{stats.pandemic=true;}, check:()=>stats.pandemic},
            {t:"🧪 神経毒", d:"毒ガスの範囲内にいる敵の移動速度を大幅に下げる。", f:()=>{stats.neurotoxin=true;}, check:()=>stats.neurotoxin},
            {t:"🧊 コールドフラスコ", d:"攻撃時、10%の確率で敵を凍結させる。", f:()=>{stats.coldFlask=true;}, check:()=>stats.coldFlask},
            {t:"🤢 腐食液", d:"毒ガスのダメージ間隔が半分になり、火力が倍増する。", f:()=>{stats.corrosion=true;}, check:()=>stats.corrosion},
            {t:"💊 違法な興奮剤", d:"移動速度+20、連射速度+20%。ただし被ダメージが1.5倍になる。", f:()=>{stats.spd+=20; stats.rate-=5; stats.armor-=5;}, check:()=>stats.drugMode}, // drugModeフラグ追加要
            {t:"🌧️ アシッドレイン", d:"3秒ごとにランダムな場所に強力な酸の雨（毒沼）を降らせる。", f:()=>{stats.acidRain=true;}, check:()=>stats.acidRain},
            // ▼ 新規追加
            {t:"🧟 ゾンビウイルス", d:"倒した敵が一定確率で味方のミニオンとして復活する。", f:()=>{stats.zombieVirus=true;}, check:()=>stats.zombieVirus},
            {t:"⚗️ ケミカル・バーン", d:"毒状態の敵に攻撃すると、追加で爆発ダメージを与える。", f:()=>{stats.chemicalBurn=true;}, check:()=>stats.chemicalBurn}
        ]);        
    } else if(player.class === 'Trickster') {
        pool = pool.concat([
            {t:"🎰 スロットマシン", d:"5秒ごとにランダムなステータスが劇的に変化する。", f:()=>{stats.slotMachine=true;}, check:()=>stats.slotMachine},
            {t:"🃏 ジョーカー", d:"HPが減るほど、クリティカル率と回避率が超上昇する。", f:()=>{stats.joker=true;}, check:()=>stats.joker},
            {t:"🎲 ロシアンルーレット", d:"1/6の確率でダメージが10倍になるが、たまに不発になる。", f:()=>{stats.russianRoulette=true;}, check:()=>stats.russianRoulette},
            {t:"✨ マジックカード", d:"弾が敵を貫通し、壁で跳ね返るようになる。", f:()=>{stats.pierce+=2; stats.shotBounce=true;}, check:()=>stats.shotBounce},
            {t:"💰 ジャックポット", d:"敵を倒した時、稀に大量の経験値オーブが爆発四散する。", f:()=>{stats.jackpot=true;}, check:()=>stats.jackpot},
            {t:"🌀 カオス弾", d:"弾が不規則に蛇行し、サイズもバラバラになる。", f:()=>{stats.chaosShot=true;}, check:()=>stats.chaosShot},
            // ▼ 新規追加
            {t:"🎲 ラッキーセブン", d:"7発ごとの攻撃が必ずクリティカル＆範囲攻撃になる。", f:()=>{stats.luckySeven=true;}, check:()=>stats.luckySeven},
            {t:"🃏 ワイルドカード", d:"他のクラスの禁断の力（スキル）がランダムで1つ発動する。", f:()=>{stats.wildCard=true; /* 実装は要工夫 */}, check:()=>stats.wildCard}
        ]);
    }

    // ★ 重複チェック: check関数を実行してtrueならリストから除外する
    pool = pool.filter(p => !p.check || !p.check());

    pool.sort(() => Math.random() - 0.5);
    let opts = pool.slice(0, 3);

    // Singularity (Lv100+)
    if(level >= 100) {
        let singOpt = {t:"🌌 限界突破 (SINGULARITY)", d:"全ステータス +20%UP", f:()=>{
            stats.dmg*=1.2; stats.spd+=1; stats.rate*=0.9; stats.bulletSpeed*=1.2; player.maxHp*=1.2; player.hp=player.maxHp;
        }};
        
        let el = document.createElement('div'); el.className='card singularity';
        el.innerHTML = `<span class="icon">🌌</span><h3>${singOpt.t}</h3><p>${singOpt.d}</p>`;
        el.onclick = () => { singOpt.f(); resume(); };
        c.appendChild(el);
        opts = opts.slice(0, 2); 
    }

    opts.forEach(o => {
        let el = document.createElement('div'); el.className='card milestone';
        let icon = o.t.split(' ')[0]; let title = o.t.split(' ').slice(1).join(' ');
        el.innerHTML = `<span class="icon">${icon}</span><h3>${title}</h3><p>${o.d}</p>`;
        el.onclick = () => { o.f(); resume(); };
        c.appendChild(el);
    });
}

function showUpgrade() {
    gameActive = false;
    let m = document.getElementById('menu-overlay'); 
    let c = document.getElementById('card-area');
    c.innerHTML = ''; 
    m.style.display = 'flex';
    document.querySelector('#menu-title').innerText = "LEVEL UP!";

    // アップグレード生成用ヘルパー
    const createOpt = (id, icon, title, val, unit, applyFunc, descGen) => {
        return { id: id, icon: icon, title: title, val: val, unit: unit, func: applyFunc, desc: descGen };
    };

    let pool = [];

    // =========================================
    // 1. 全クラス共通 (Universal Stats)
    // =========================================
    pool.push(createOpt('dmg_p', '💪', '攻撃力UP', 15, '%', (v)=>stats.dmg=Math.floor(stats.dmg*(1+v/100)), (v)=>`ダメージ +${v}%`));
    pool.push(createOpt('hp', '❤️', '最大HP', 50, '', (v)=>{player.maxHp+=v; player.hp+=v;}, (v)=>`HP +${v}`));
    pool.push(createOpt('spd', '👟', '移動速度', 2, '', (v)=>stats.spd+=v, (v)=>`速度 +${v}`));
    pool.push(createOpt('crit', '🎯', 'クリティカル', 5, '%', (v)=>stats.critChance+=v/100, (v)=>`会心率 +${v}%`));
    pool.push(createOpt('magnet', '🧲', '収集範囲', 50, '', (v)=>stats.magnet+=v, (v)=>`範囲 +${v}`));
    
    // 全クラス共通：雷撃
    pool.push(createOpt('lightning', '🌩️', '雷撃強化', 1, 'Lv', (v)=>stats.lightning+=v, (v)=>`雷撃レベル +${v}`));

    // レア枠：回復
    if(Math.random() < 0.2) {
        pool.push(createOpt('super_regen', '🏥', '超回復', 10, '', (v)=>stats.regen+=v, (v)=>`HP回復 +${v}/s`));
    } else {
        pool.push(createOpt('regen', '💖', 'リジェネ', 2, '', (v)=>stats.regen+=v, (v)=>`HP回復 +${v}/s`));
    }

    // =========================================
    // 2. クラス固有ウェポン & 特殊ステータス
    // =========================================

    // ★ ビット (スナイパー or 所持時)
    if(player.class === 'Sniper' || stats.drones > 0) {
        pool.push(createOpt('drone', '🛰️', 'ビット増設', 1, '機', (v)=>stats.drones+=v, (v)=>`ビット数 +${v}`));
        pool.push(createOpt('drone', '🛰️', 'ビット増設', 1, '機', (v)=>stats.drones+=v, (v)=>`ビット数 +${v}`));
    }
    // ★ ミサイル (アサルト or 所持時)
    if(player.class === 'Assault' || stats.missile > 0) {
        pool.push(createOpt('missile', '🚀', 'ミサイル', 1, 'Lv', (v)=>stats.missile+=v, (v)=>`発射数/頻度 +${v}`));
        pool.push(createOpt('missile', '🚀', 'ミサイル', 1, 'Lv', (v)=>stats.missile+=v, (v)=>`発射数/頻度 +${v}`));
    }
    // ★ チャクラム (トリックスター or 所持時)
    if(player.class === 'Trickster' || stats.chakram > 0) {
        pool.push(createOpt('chakram', '🥏', 'チャクラム', 1, '個', (v)=>stats.chakram+=v, (v)=>`同時投擲数 +${v}`));
    }

    // ★【復活＆修正】ホーミング (射撃系クラス用 + Novice追加)
    // ヴァンガード(Melee)以外なら出現するように設定
    if(player.class !== 'Melee' || stats.homing > 0) {
        // 出やすいように2回登録
        pool.push(createOpt('homing', '👁️', 'ホーミング', 1, 'Lv', (v)=>stats.homing+=v, (v)=>`追尾性能 +${v}`));
        pool.push(createOpt('homing', '👁️', 'ホーミング', 1, 'Lv', (v)=>stats.homing+=v, (v)=>`追尾性能 +${v}`));
    }

    // =========================================
    // 3. クラス別ステータス重み付け
    // =========================================
    
    // 攻撃範囲
    let areaWeight = 1;
    if(player.class === 'Melee' || player.class === 'Guardian' || player.class === 'Alchemist') areaWeight = 3; 
    for(let i=0; i<areaWeight; i++) {
        pool.push(createOpt('area', '💥', '攻撃範囲', 10, '%', (v)=>{
            stats.areaScale += v/100;
            if(player.class === 'Melee') player.size *= 1.05; 
        }, (v)=>`サイズ +${v}%`));
    }

    // 弾速 (近接以外)
    if(player.class !== 'Melee' && player.class !== 'Samurai' && player.class !== 'Guardian') {
        pool.push(createOpt('bullet_speed', '🚅', '弾速', 10, '%', (v)=>stats.bulletSpeed*=(1+v/100), (v)=>`弾の速さ +${v}%`));
    }

    // 貫通 (射撃系)
    if(['Sniper', 'Assault', 'Trickster', 'Tempest', 'Novice'].includes(player.class)) {
        pool.push(createOpt('pierce', '🏹', '貫通力', 1, '', (v)=>stats.pierce+=v, (v)=>`貫通数 +${v}`));
    }

    // 連射速度
    pool.push(createOpt('rate', '⚡', 'クールダウン', 5, '%', (v)=>stats.rate=Math.max(2, stats.rate*(1-v/100)), (v)=>`攻撃間隔 -${v}%`));

    // 持続時間
    if(player.class === 'Alchemist' || player.class === 'Guardian' || stats.clusterMine || stats.poison > 0) {
        pool.push(createOpt('duration', '⏳', '効果時間', 15, '%', (v)=>stats.duration+=v/100, (v)=>`持続時間 +${v}%`));
    }

    // 防御力
    if(['Melee', 'Samurai', 'Guardian'].includes(player.class)) {
        pool.push(createOpt('armor', '🛡️', '装甲強化', 2, '', (v)=>stats.armor+=v, (v)=>`被ダメージ -${v}`));
        pool.push(createOpt('armor', '🛡️', '装甲強化', 2, '', (v)=>stats.armor+=v, (v)=>`被ダメージ -${v}`));
    }
    
    // ノックバック
    if(['Melee', 'Sniper', 'Assault', 'Novice'].includes(player.class)) {
        pool.push(createOpt('knockback', '🥊', '衝撃力', 1, '', (v)=>stats.knockback+=v, (v)=>`ノックバック +${v}`));
    }

    // マルチショット
    if(player.class === 'Melee') {
        pool.push(createOpt('multi', '⚔️', '回転刃+', 1, '', (v)=>stats.multi+=v, (v)=>`回転刃の数 +${v}`));
    } else if(player.class === 'Samurai') {
        pool.push(createOpt('multi', '🌊', '衝撃波+', 1, '', (v)=>stats.multi+=v, (v)=>`衝撃波の数 +${v}`));
    } else {
        // Novice含む射撃系
        pool.push(createOpt('multi', '🔫', 'マルチショット', 1, '', (v)=>stats.multi+=v, (v)=>`同時発射数 +${v}`));
    }

    // =========================================
    // 4. 抽選
    // =========================================
    let choices = [];
    let safety = 0;
    
    pool.sort(() => Math.random() - 0.5);

    while(choices.length < 3 && safety < 100) {
        let base = pool[safety % pool.length]; 
        if(!choices.some(c => c.id === base.id)) {
            let opt = { ...base }; 
            if(Math.random() < 0.1) {
                opt.isRare = true;
                let mult = 2; 
                if(opt.id === 'hp') mult = 3; 
                opt.val = Math.floor(opt.val * mult);
            }
            choices.push(opt);
        }
        safety++;
    }

    choices.forEach(o => {
        let el = document.createElement('div'); 
        el.className = 'card';
        if(o.isRare) el.classList.add('rare');
        
        let title = o.isRare ? `✨ ${o.title}` : o.title;
        let desc = o.desc(o.val);
        
        el.innerHTML = `<span class="icon">${o.icon}</span><h3>${title}</h3><p>${desc}</p>`;
        el.onclick = () => { o.func(o.val); resume(); };
        c.appendChild(el);
    });
}

function showEvo() {
    gameActive = false;
    let m = document.getElementById('menu-overlay'); let c = document.getElementById('card-area');
    c.innerHTML = ''; m.style.display = 'flex';
    document.querySelector('#menu-title').innerText = "クラス進化";

    let evos = [
        // --- 新規追加クラス ---
        {t:"⚔️ 侍・剣豪 (Samurai)", d:"一閃: 射程は短いが、前方の敵を一瞬で葬る「斬撃」を放つ。", f:()=>{
            player.class="Samurai"; player.color="#ffffff"; // 白銀
            stats.samuraiMode = true; // 専用フラグ
            stats.rate = 20; // 攻撃間隔は遅い
            stats.dmg = 300; // 一撃が重い
            stats.spd += 5;  // 足が速い
            stats.pierce = 999; // 無限貫通
            stats.knockback = 0; // ノックバックさせず切り裂く
        }},
        {t:"⚡ 雷帝 (Tempest)", d:"天変地異: 常に周囲に落雷が発生し、攻撃弾も連鎖雷撃を引き起こす。", f:()=>{
            player.class="Tempest"; player.color="#8A2BE2"; // 紫電
            stats.tempestMode = true; // 専用フラグ
            stats.rate = 8;  // 高速連射
            stats.dmg = 15;  
            stats.lightning = 3; // 最初からライトニングLv3
            stats.bulletSpeed = 25; // 弾速も速い
        }},
        // --- 既存クラス ---
        {t:"🔫 アサルト", d:"連射特化: マシンガン(連射・2発・貫通)解禁", f:()=>{
            player.class="Assault"; player.color="#00ffff"; 
            stats.rate=4; stats.dmg+=10; stats.multi=1; stats.pierce=1; 
        }},
        {t:"🛡️ ヴァンガード", d:"近接: 超・広範囲 & HP+500/リジェネ+10", f:()=>{
            player.class="Melee"; player.color="#ff3333"; 
            stats.aura=true; stats.auraRange=180; stats.spd+=4; 
            player.maxHp+=500; player.hp+=500; stats.regen+=10; 
        }},
        {t:"🔭 スナイパー", d:"遠距離: 💥破片 & 🔙ノックバック", f:()=>{
            player.class="Sniper"; player.color="#ffff00"; 
            stats.rate=35; stats.dmg=200; stats.pierce=2; stats.bulletSpeed=30; stats.multi=0;
            stats.drones+=1; stats.shrapnel=true; stats.knockback=1; 
        }},
        {t:"🧱 ガーディアン", d:"機動要塞: タレット8基展開・反射装甲・高耐久", f:()=>{
            player.class="Guardian"; player.color="#00ff88"; 
            stats.armor+=20; player.maxHp+=1500; player.hp=player.maxHp; 
            stats.spd-=0.5; stats.magnet+=200; stats.sentryRate=2.5; 
            stats.sentryMax=6; stats.sentrySystem=true; spawnSentry(); stats.spikeReflect=true; 
        }},
        {t:"⚗️ アルケミスト", d:"毒物劇物: 毒ガス・凍結・弱体化をバラ撒く", f:()=>{
            player.class="Alchemist"; player.color="#aa00ff"; 
            stats.poison = 5; stats.dmg *= 0.7; stats.rate *= 0.9; 
            stats.alchemistMode = true; stats.neurotoxin = false; stats.pandemic = false;
        }},
        {t:"🃏 トリックスター", d:"運否天賦: 弾の性能が毎回ランダムに変化する。", f:()=>{
            player.class="Trickster"; player.color="#ff00ff"; 
            stats.rate = 5; stats.dmg = 10; stats.tricksterMode = true; 
            stats.slotMachine = false; stats.joker = false; 
        }}
    ];

    evos.forEach(o => {
        let el = document.createElement('div'); el.className='card';
        let icon = o.t.split(' ')[0]; let title = o.t.split(' ').slice(1).join(' ');
        el.innerHTML = `<span class="icon">${icon}</span><h3>${title}</h3><p>${o.d}</p>`;
        el.onclick = () => { 
            o.f(); 
            let nameSpan = document.getElementById('disp-class-name');
            nameSpan.innerText = `(${title})`;
            nameSpan.style.color = player.color;
            resume(); 
        };
        c.appendChild(el);
    });
}

function resume() {
    document.getElementById('menu-overlay').style.display = 'none';
    lastTime = performance.now(); gameActive = true; updateSkillList(); requestAnimationFrame(loop);
}

function createParticles(x,y,c,n,sizeBase) { 
    if(particles.length > MAX_PARTICLES) return; 
    for(let i=0;i<n;i++) particles.push({ x:x, y:y, vx:(Math.random()-0.5)*12, vy:(Math.random()-0.5)*12, life:10+Math.random()*5, size:(sizeBase||4)+Math.random()*2, color:c }); 
}

function updateStatsDisplay() {
    const s = stats;
    let atkPerSec = (60 / s.rate).toFixed(1); 
    
    let html = `
        ATK  : ${Math.floor(s.dmg)} <br>
        ASP  : ${atkPerSec}/s <br>
        CRIT : ${(s.critChance * 100).toFixed(0)}% <br>
        AREA : ${(s.areaScale * 100).toFixed(0)}% <br>
        SPD  : ${s.spd.toFixed(1)} <br>
        BSPD : ${s.bulletSpeed.toFixed(0)} <br>
        PIRC : ${s.pierce} <br>
        MAG  : ${Math.floor(s.magnet)} <br>
        ARM  : ${s.armor}
    `;
    
    if(s.duration > 1.0) html += `<br>DUR  : ${(s.duration*100).toFixed(0)}%`;
    if(s.knockback > 0) html += `<br>KBCK : ${s.knockback}`;

    document.getElementById('stats-list').innerHTML = html;
}

function updateUI() {
    document.getElementById('disp-lv').innerText = level;
    let hpPer = Math.max(0, player.hp / player.maxHp * 100);
    document.getElementById('hp-bar-fill').style.width = hpPer + '%';
    document.getElementById('disp-hp-val').innerText = Math.floor(player.hp);
    document.getElementById('disp-hp-max').innerText = Math.floor(player.maxHp);
    document.getElementById('disp-regen').innerText = stats.regen;
    document.getElementById('disp-score').innerText = score;

    updateStatsDisplay();
}

function updateSkillList() {
    let list = document.getElementById('skill-list');
    let html = "";
    if(singularityMode) html += `<div style="color:#000; text-shadow:0 0 5px #fff; font-weight:bold;">🌌 SINGULARITY MODE</div>`;

    if(stats.omegaLaser) html += `<div style="color:#f0f">⚡ OMEGA LASER</div>`;
    if(stats.absoluteZero) html += `<div style="color:#0ff">❄️ ZERO AURA</div>`;
    if(stats.titan) html += `<div style="color:#f00">🦍 TITAN</div>`;
    if(stats.gatling) html += `<div style="color:#0ff">⚙️ GATLING</div>`;
    if(stats.railgun) html += `<div style="color:#ff0">🚅 RAILGUN</div>`;
    
    // Guardian Skills
    if(stats.sentrySystem) html += `<div style="color:#0f0">🏗️ SENTRY SYS (${sentries.length})</div>`;
    if(stats.siegeMode) {
        let active = stats.isStationary ? "(ON)" : "(OFF)";
        html += `<div style="color:#0f0">🏯 SIEGE ${active}</div>`;
    }
    if(stats.reactiveArmor) html += `<div style="color:#0f0">⚡ REACTIVE ARMOR</div>`;
    if(stats.forceField) {
        let ready = stats.forceFieldCd <= 0 ? "READY" : Math.ceil(stats.forceFieldCd/60)+"s";
        html += `<div style="color:#0ff">🛡️ FORCE FIELD [${ready}]</div>`;
    }

    if(stats.chainBurst) html += `<div style="color:#0ff">💥 CHAIN BURST</div>`;
    if(stats.electroFence) html += `<div style="color:#0ff">⚡ ELECTRO FENCE</div>`;
    if(stats.armor > 0) html += `<div style="color:#8f8">🛡️ ARMOR +${stats.armor}</div>`;
    if(stats.shrapnel) html += `<div style="color:#ff0">💥 SHRAPNEL</div>`;

    if(stats.missile > 0) html += `<div style="color:#fa0">🚀 ミサイル Lv${stats.missile}</div>`;
    if(stats.drones > 0) html += `<div style="color:#ff0">🛰️ ドローン x${stats.drones}</div>`;
    if(stats.auraScale > 1) html += `<div style="color:#f00">🛡️ オーラ倍率 x${stats.auraScale.toFixed(1)}</div>`;
    if(stats.lifesteal > 0) html += `<div style="color:#f0f">🧛 吸血 +${stats.lifesteal}</div>`;
    list.innerHTML = html;
}

function gameOver() {
    gameActive = false;
    document.getElementById('final-score').innerText = score;
    document.getElementById('game-over').style.display = 'flex';
}

function triggerWarning() {
    Sound.play('alert');
    let overlay = document.getElementById('warning-overlay');
    overlay.style.display = 'flex'; // CSSでflexレイアウトが指定されているためflexにする
}

updateUI();
</script>
</body>
</html>
