<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Evo Lite v3.1.3: Rare & Percent Update</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Hiragino Kaku Gothic ProN', sans-serif; user-select: none; touch-action: none; -webkit-touch-callout: none; transition: filter 2s; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        /* UI Layers */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #top-bar { position: absolute; top: 15px; left: 50%; transform: translateX(-50%); text-align: center; color: white; text-shadow: 0 2px 4px rgba(0,0,0,0.8); width: 80%; max-width: 600px; }
        #xp-bg { width: 100%; height: 12px; background: #222; margin-top: 8px; border: 1px solid #555; border-radius: 6px; overflow: hidden; box-shadow: 0 0 10px rgba(0,0,0,0.5);}
        #xp-fill { width: 0%; height: 100%; background: linear-gradient(90deg, #00ffff, #0088ff); transition: width 0.1s; }
        #skill-list { position: absolute; top: 60px; right: 20px; text-align: right; color: rgba(255,255,255,0.8); font-size: 11px; line-height: 1.4; text-shadow: 1px 1px 2px #000; pointer-events: none; }
        
        #hp-container { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); width: 300px; text-align: center; color: white; font-weight: bold; pointer-events: none; }
        #hp-bar-bg { width: 100%; height: 16px; background: #330000; border: 2px solid #555; border-radius: 8px; overflow: hidden; margin-top:5px; box-shadow: 0 0 10px #f00; }
        #hp-bar-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #ff4444, #ff0000); transition: width 0.1s; }
        #hp-regen-text { position: absolute; right: -50px; top: 2px; color: #0f0; font-size: 12px; animation: pulse 1s infinite; }
        @keyframes pulse { 0%{opacity:0.5;} 50%{opacity:1;} 100%{opacity:0.5;} }
        #score-box { position: absolute; top: 20px; left: 20px; color: #fff; font-size: 16px; font-weight: bold; text-shadow: 0 0 5px #000; }
        
        /* Mobile Controls */
        #mobile-controls { display: none; position: absolute; top:0; left:0; width:100%; height:100%; pointer-events: none; }
        #joystick-zone { position: absolute; width: 100px; height: 100px; border: 2px solid rgba(255,255,255,0.2); border-radius: 50%; display: none; transform: translate(-50%, -50%); pointer-events: none; }
        #joystick-knob { position: absolute; width: 40px; height: 40px; background: rgba(0, 255, 255, 0.5); border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none; }
        #dash-btn { 
            position: absolute; bottom: 40px; right: 40px; width: 80px; height: 80px; 
            background: rgba(255, 255, 0, 0.3); border: 2px solid rgba(255, 255, 0, 0.6); 
            border-radius: 50%; pointer-events: auto; display: none;
            justify-content: center; align-items: center; color: #fff; font-size: 30px; user-select: none;
        }
        #dash-btn:active { background: rgba(255, 255, 0, 0.6); transform: scale(0.95); }

        /* Overlays */
        #warning-overlay { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 40%, rgba(200,0,0,0.7) 100%); animation: pulseRed 0.2s infinite alternate; justify-content: center; align-items: center; flex-direction: column; z-index: 10; }
        #warning-text { color: #ff0000; font-size: 60px; font-weight: 900; letter-spacing: 5px; text-shadow: 0 0 20px red; transform: scale(1); animation: textZoom 0.1s infinite alternate; text-align: center; }
        @keyframes pulseRed { from { opacity: 0.2; } to { opacity: 0.8; } }
        @keyframes textZoom { from { transform: scale(0.95); } to { transform: scale(1.05); } }
        
        #menu-overlay, #start-screen, #game-over { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.92); pointer-events: auto; z-index: 20; display: none; justify-content: center; align-items: center; flex-direction: column; }
        #start-screen { display: flex; }
        .card-container { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; max-height: 80vh; overflow-y: auto; padding: 10px; }
        .card { width: 140px; background: #222; border: 1px solid #444; padding: 15px; color: white; cursor: pointer; text-align: center; transition: 0.1s; position: relative; overflow: hidden; border-radius: 8px; flex-shrink: 0; display: flex; flex-direction: column; align-items: center; }
        .card:hover, .card:active { background: #333; border-color: #0ff; transform: translateY(-5px) scale(1.05); box-shadow: 0 0 20px rgba(0,255,255,0.4); }
        
        /* Card Types */
        .card.special { border-color: #ff0; background: #332200; } 
        .card.milestone { border-color: #f0f; background: #220022; }
        .card.milestone:hover { border-color: #fff; background: #440044; box-shadow: 0 0 30px rgba(255,0,255,0.6); }
        
        /* Rare Upgrade Style */
        .card.rare { border-color: #ffd700; background: linear-gradient(135deg, #443300, #221100); box-shadow: 0 0 25px rgba(255, 215, 0, 0.6); animation: glow 2s infinite alternate; }
        .card.rare h3 { color: #ffd700; text-shadow: 0 0 5px #ffaa00; }
        .card.rare p { color: #ffebcd; font-weight: bold; }
        @keyframes glow { from { box-shadow: 0 0 10px #b8860b; } to { box-shadow: 0 0 25px #ffd700; } }

        .card.singularity { border-color: #000; background: #fff; color:#000; box-shadow: 0 0 30px #fff; }
        .card.singularity h3 { color: #000; }
        .card.singularity p { color: #333; }
        
        .card.evo { width: 220px; border-color: #0f0; background: #002211; box-shadow: 0 0 15px #0f0; padding: 20px; }
        .card.evo h3 { color: #0f0; font-size: 18px; margin: 10px 0; border-bottom: 1px solid #0f0; padding-bottom: 5px; width: 100%; }
        .card.evo p { font-size: 12px; color: #dfd; line-height: 1.5; text-align: left; width: 100%; }
        .card.evo .tag { display:inline-block; background:#0f0; color:#000; font-size:10px; padding:2px 5px; border-radius:4px; margin-bottom:5px; font-weight:bold;}

        .card .icon { font-size: 30px; margin-bottom: 5px; display: block; }
        .card h3 { color: #0ff; margin: 5px 0; font-size: 14px; }
        .card.special h3 { color: #ff0; }
        .card.milestone h3 { color: #f0f; }
        .card p { font-size: 11px; color: #ccc; line-height: 1.3; }
        
        button { padding: 20px 50px; font-size: 24px; cursor: pointer; background: #fff; border: none; font-weight: bold; margin-top: 30px; border-radius: 6px; transition: 0.2s; box-shadow: 0 0 10px #fff; }
        button:active { background: #0ff; box-shadow: 0 0 20px #0ff; transform: scale(0.95); }
        
        .singularity-mode #gameCanvas { filter: invert(1) hue-rotate(180deg); }
        .singularity-mode #ui-layer { filter: invert(0); }
    </style>
</head>
<body id="main-body">

<canvas id="gameCanvas"></canvas>

<div id="mobile-controls">
    <div id="joystick-zone"><div id="joystick-knob"></div></div>
    <div id="dash-btn">⚡</div>
</div>

<div id="ui-layer">
    <div id="score-box">SCORE: <span id="disp-score">0</span><br>TIME: <span id="disp-time">00:00</span></div>
    <div id="top-bar">
        <span style="font-size: 20px; font-weight: bold;">LV <span id="disp-lv">1</span> <span id="disp-class-name" style="font-size:12px; color:#aaa;">(Novice)</span></span>
        <div id="xp-bg"><div id="xp-fill"></div></div>
    </div>
    <div id="skill-list"></div>
    <div id="hp-container">
        HP <span id="disp-hp-val">100</span> / <span id="disp-hp-max">100</span>
        <div id="hp-bar-bg"><div id="hp-bar-fill"></div></div>
        <div id="hp-regen-text">+<span id="disp-regen">1</span>/s</div>
    </div>
</div>

<div id="warning-overlay">
    <div id="warning-text">WARNING</div>
    <div style="color:white; font-size:20px; margin-top:10px; font-weight:bold;">BOSS DETECTED</div>
</div>

<div id="menu-overlay">
    <h1 id="menu-title" style="color:white; font-size:32px; margin-bottom: 20px; text-shadow: 0 0 15px #0ff;">LEVEL UP!</h1>
    <div class="card-container" id="card-area"></div>
</div>

<div id="start-screen">
    <h1 style="font-size:50px; margin:0; letter-spacing: 5px; color:#fff; text-shadow:0 0 20px #0ff; text-align:center;">EVO LITE</h1>
    <h2 style="color:#ffd700; font-weight:normal; font-size:16px;">v3.1.3 RARE & PERCENT UPDATE</h2>
    <p style="color:#aaa; margin-top:10px; font-size:12px;">PC: WASD + SPACE | Mobile: Touch & Tap</p>
    <button onclick="startGame()">START</button>
</div>

<div id="game-over">
    <h1 style="color:red; font-size:50px; text-shadow: 0 0 20px red;">DEFEATED</h1>
    <p style="font-size:24px; color:white;">SCORE: <span id="final-score"></span></p>
    <button onclick="location.reload()">RETRY</button>
</div>

<script>
// --- Config ---
const MAX_ENEMIES = 1000;
const MAX_PARTICLES = 500; 
const MAX_ORBS = 400; 
const MAX_TEXTS = 50;
const MAX_SOUND_CONCURRENT = 32; 

const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
if(isMobile) {
    document.getElementById('mobile-controls').style.display = 'block';
    document.getElementById('dash-btn').style.display = 'flex';
}

let joyTouchId = null;
let joyStartX = 0, joyStartY = 0;
let joyMoveX = 0, joyMoveY = 0;
const JOY_MAX_RADIUS = 50;

const AudioCtx = window.AudioContext || window.webkitAudioContext;
let actx = null;
let lastSoundTime = {};

// ★ Sound Engine
const Sound = {
    activeEndTimes: [],
    init: () => { 
        if(!actx) {
            actx = new AudioCtx(); 
            const resumeFunc = () => {
                if(actx.state === 'suspended') actx.resume();
                window.removeEventListener('click', resumeFunc);
                window.removeEventListener('touchstart', resumeFunc);
                window.removeEventListener('keydown', resumeFunc);
            };
            window.addEventListener('click', resumeFunc);
            window.addEventListener('touchstart', resumeFunc);
            window.addEventListener('keydown', resumeFunc);
        }
    },
    update: () => {
        if(!actx) return;
        const now = actx.currentTime;
        Sound.activeEndTimes = Sound.activeEndTimes.filter(t => t > now);
    },
    play: (type, pitch = 1.0) => {
        if(!actx) Sound.init();
        if(!actx) return;
        if(actx.state === 'suspended') actx.resume().catch(()=>{});
        if(Sound.activeEndTimes.length >= MAX_SOUND_CONCURRENT) return;

        const now = actx.currentTime;
        if(lastSoundTime[type] && now - lastSoundTime[type] < 0.05) return;
        lastSoundTime[type] = now;

        const osc = actx.createOscillator();
        const gain = actx.createGain();
        osc.connect(gain);
        gain.connect(actx.destination);

        if(level >= 100) pitch *= 0.8;

        let duration = 0.1;
        if(type === 'shoot') {
            duration = 0.1; osc.frequency.setValueAtTime(300 * pitch, now); osc.frequency.exponentialRampToValueAtTime(50, now+0.1); gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now+0.1);
        } else if(type === 'missile') { 
            duration = 0.3; osc.type='square'; osc.frequency.setValueAtTime(150, now); osc.frequency.linearRampToValueAtTime(400, now+0.2); gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now+0.3);
        } else if(type === 'hit') {
            duration = 0.05; osc.type='square'; osc.frequency.setValueAtTime(100 * pitch, now); gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now+0.05);
        } else if(type === 'dash') {
            duration = 0.2; osc.type='triangle'; osc.frequency.setValueAtTime(600, now); osc.frequency.linearRampToValueAtTime(200, now+0.2); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.2);
        } else if(type === 'laser') {
            duration = 0.5; osc.type='sawtooth'; osc.frequency.setValueAtTime(800, now); osc.frequency.linearRampToValueAtTime(200, now+0.5); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.5);
        } else if(type === 'freeze') {
            duration = 0.3; osc.type='sine'; osc.frequency.setValueAtTime(2000, now); osc.frequency.linearRampToValueAtTime(1000, now+0.3); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.3);
        } else if(type === 'explode') {
            duration = 0.2; osc.type='sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.exponentialRampToValueAtTime(10, now+0.2); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.2);
        } else if(type === 'levelup') {
            duration = 0.6; osc.type='triangle'; osc.frequency.setValueAtTime(440, now); osc.frequency.setValueAtTime(554, now+0.1); osc.frequency.setValueAtTime(659, now+0.2); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.6);
        } else if(type === 'milestone') {
            duration = 0.8; osc.type='sawtooth'; osc.frequency.setValueAtTime(110, now); osc.frequency.linearRampToValueAtTime(440, now+0.8); gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now+0.8);
        } else if(type === 'alert') {
            duration = 0.5; osc.type='sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.linearRampToValueAtTime(150, now+0.5); gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now+0.5);
        } else if(type === 'exp') {
            duration = 0.1; osc.type='sine'; let freq = 1000 * pitch; osc.frequency.setValueAtTime(freq, now); osc.frequency.linearRampToValueAtTime(freq + 500, now+0.05); gain.gain.setValueAtTime(0.03, now); gain.gain.linearRampToValueAtTime(0, now+0.1);
        } else if(type === 'bounce') {
            duration = 0.1; osc.type='triangle'; osc.frequency.setValueAtTime(600, now); osc.frequency.linearRampToValueAtTime(300, now+0.1); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.1);
        } else if(type === 'bash') {
            duration = 0.2; osc.type='square'; osc.frequency.setValueAtTime(100, now); osc.frequency.linearRampToValueAtTime(50, now+0.2); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.2);
        } else if(type === 'lightning') {
            duration = 0.2; osc.type='sawtooth'; osc.frequency.setValueAtTime(800, now); osc.frequency.linearRampToValueAtTime(100, now+0.2); gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now+0.2);
        } else if(type === 'spark') {
            duration = 0.15; osc.type='sawtooth'; osc.frequency.setValueAtTime(2000, now); osc.frequency.linearRampToValueAtTime(500, now+0.15); gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now+0.15);
        } else if(type === 'powerup') {
            duration = 0.5; osc.type='sine'; osc.frequency.setValueAtTime(440, now); osc.frequency.linearRampToValueAtTime(880, now+0.25); osc.frequency.linearRampToValueAtTime(1760, now+0.5); gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now+0.5);
        }
        osc.start(now); osc.stop(now + duration);
        Sound.activeEndTimes.push(now + duration + 0.05);
    }
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let scaleFactor = 1;
function resizeCanvas() {
    let winW = window.innerWidth;
    let winH = window.innerHeight;
    const isPortrait = winH > winW;
    const targetWidth = isPortrait ? 900 : 1600;
    scaleFactor = winW < targetWidth ? targetWidth / winW : 1;
    canvas.width = winW * scaleFactor;
    canvas.height = winH * scaleFactor;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas(); 

let lastTime = 0;
let startTime = 0;
let gameActive = false;
let score = 0;
let level = 1;
let exp = 0;
let nextExp = 50; 
let screenShake = 0;
let bossCycleCounter = 0; 
let bossWarningTimer = 0;
let bossWarningActive = false; 
let earthquakeTimer = 0;
let electroFenceTimer = 0; 
let singularityMode = false;

// Guardian Sentry
let sentries = [];
let sentryTimer = 0;

// Items
let items = [];

let player = {
    x: canvas.width/2, y: canvas.height/2, size: 15,
    hp: 100, maxHp: 100,
    class: 'Novice', subClass: null, color: '#00ffff',
    invincible: 0,
    dashCd: 0, maxDashCd: 120,
    slamCd: 0,
    laserCd: 0, freezeCd: 0,
    // Unique states
    sunCharge: 0, // Crusader
    isMoving: false
};

let stats = {
    spd: 7, dmg: 15, rate: 25, multi: 1, 
    bulletSpeed: 16, pierce: 0, 
    aura: false, auraRange: 0,
    regen: 1, magnet: 150, 
    homing: 0, lightning: 0, poison: 0, spinBlade: 0, chakram: 0,
    missile: 0, drones: 0, auraScale: 1,
    lifesteal: 0, critChance: 0, infinitePierce: false,
    missileBlast: 1, gravityAura: false, spreadShot: false,
    napalm: false, spikeArmor: false, dashNova: false, 
    splitShot: false, giantSlayer: false,
    armor: 0, 
    knockback: 0, shrapnel: false, 
    
    // Guardian Skills
    sentrySystem: false, siegeMode: false, reactiveArmor: false, 
    nanoRepair: false, clusterMine: false, forceField: false,
    forceFieldCd: 0, isStationary: false,
    sentryMax: 5, sentryRate: 1.0,
    
    // Forbidden Skills
    shotExplode: false, shotBounce: false, doubleShot: false, 
    missileChance: 0, infiniteMag: false, gatling: false,
    titan: false, blackHole: false, bladeStorm: false, 
    earthquake: false, spikeReflect: false, bloodLust: false,
    railgun: false, execute: false, deadeye: false, 
    electroFence: false, chainBurst: false, orbital: false,
    omegaLaser: false, absoluteZero: false, necromancer: false,

    // Sub Class Specifics
    ghostShot: false, // Dimension Walker
    prismSplit: false, // Prism Shooter
    isEarthShaker: false,
    teslaGrid: false,
    bulletStorm: false, // Assault B
    clusterStriker: false // Assault A
};

let bullets = [];
let enemyBullets = [];
let enemies = [];
let particles = [];
let expOrbs = [];
let texts = [];
let orbitals = [];
let drones = []; 
let gasClouds = [];
let spikeBits = [];
// Flying Swords
let flyingSwords = [];

const keys = {};

window.addEventListener('keydown', e => { keys[e.key] = true; if(e.code === 'Space') dash(); });
window.addEventListener('keyup', e => keys[e.key] = false);

document.getElementById('dash-btn').addEventListener('touchstart', (e) => { e.preventDefault(); dash(); }, {passive: false});

window.addEventListener('touchstart', e => {
    for(let i=0; i<e.changedTouches.length; i++) {
        let t = e.changedTouches[i];
        if(t.clientX < window.innerWidth / 2 && joyTouchId === null) {
            joyTouchId = t.identifier;
            joyStartX = t.clientX;
            joyStartY = t.clientY;
            let zone = document.getElementById('joystick-zone');
            zone.style.display = 'block';
            zone.style.left = joyStartX + 'px';
            zone.style.top = joyStartY + 'px';
            updateJoystick(t.clientX, t.clientY);
        }
    }
}, {passive: false});

window.addEventListener('touchmove', e => {
    e.preventDefault(); 
    for(let i=0; i<e.changedTouches.length; i++) {
        let t = e.changedTouches[i];
        if(t.identifier === joyTouchId) {
            updateJoystick(t.clientX, t.clientY);
        }
    }
}, {passive: false});

window.addEventListener('touchend', e => {
    for(let i=0; i<e.changedTouches.length; i++) {
        let t = e.changedTouches[i];
        if(t.identifier === joyTouchId) {
            joyTouchId = null;
            joyMoveX = 0; joyMoveY = 0;
            document.getElementById('joystick-zone').style.display = 'none';
            document.getElementById('joystick-knob').style.transform = `translate(-50%, -50%)`;
        }
    }
});

function updateJoystick(cx, cy) {
    let dx = cx - joyStartX;
    let dy = cy - joyStartY;
    let dist = Math.hypot(dx, dy);
    if(dist > JOY_MAX_RADIUS) {
        dx = (dx / dist) * JOY_MAX_RADIUS;
        dy = (dy / dist) * JOY_MAX_RADIUS;
    }
    joyMoveX = dx / JOY_MAX_RADIUS;
    joyMoveY = dy / JOY_MAX_RADIUS;
    
    let knob = document.getElementById('joystick-knob');
    knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
}


function startGame() {
    document.getElementById('start-screen').style.display = 'none';
    Sound.init();
    Sound.play('levelup');
    gameActive = true;
    player.x = canvas.width/2;
    player.y = canvas.height/2;
    startTime = Date.now();
    lastTime = performance.now();
    updateSkillList();
    updateUI(); // Init UI text
    requestAnimationFrame(loop);
}

function loop(timestamp) {
    if(!gameActive) return;
    const dt = timestamp - lastTime;
    lastTime = timestamp;
    let timeScale = dt / (1000 / 60);
    if(timeScale > 4) timeScale = 4;
    
    Sound.update();

    update(timeScale);
    draw();
    requestAnimationFrame(loop);
}

function update(ts) {
    let gameTimeSec = (Date.now() - startTime) / 1000;
    
    if(level >= 100 && !singularityMode) {
        singularityMode = true;
        document.body.classList.add('singularity-mode');
        Sound.play('milestone');
    }

    let m = Math.floor(gameTimeSec/60);
    let s = Math.floor(gameTimeSec%60);
    document.getElementById('disp-time').innerText = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;

    if(player.dashCd > 0) player.dashCd -= ts;
    if(player.invincible > 0) player.invincible -= ts;
    if(player.slamCd > 0) player.slamCd -= ts;
    if(screenShake > 0) screenShake *= 0.9;
    
    // Guardian Skills Update
    if(stats.sentrySystem) {
        sentryTimer -= ts;
        if(sentryTimer <= 0) {
            spawnSentry();
            sentryTimer = 600; // 10 seconds default
        }
        sentries.forEach(s => {
            s.cooldown -= ts;
            if(s.cooldown <= 0) {
                let target = null;
                let minD = 400;
                enemies.forEach(e => {
                    if(e.dead) return;
                    let d = Math.hypot(e.x - s.x, e.y - s.y);
                    if(d < minD) { minD = d; target = e; }
                });
                if(target) {
                    let ang = Math.atan2(target.y - s.y, target.x - s.x);
                    // Sentry Rate Mod (Engineer)
                    let fireDelay = stats.rate * (1/stats.sentryRate);
                    bullets.push({type:'normal', x:s.x, y:s.y, vx:Math.cos(ang)*stats.bulletSpeed, vy:Math.sin(ang)*stats.bulletSpeed, size:6, color:'#0f0', hit:[], pierce:stats.pierce});
                    Sound.play('shoot', 1.5);
                    s.cooldown = Math.max(10, fireDelay);
                }
            }
        });
        
        // Tesla Grid Logic
        if(stats.teslaGrid && sentries.length >= 2) {
            for(let i=0; i<sentries.length; i++) {
                let s1 = sentries[i];
                let s2 = sentries[(i+1)%sentries.length]; // Connect loop
                enemies.forEach(e => {
                    if(e.dead) return;
                    // Line collision check
                    let dist = pointToLineDistance(e.x, e.y, s1.x, s1.y, s2.x, s2.y);
                    if(dist < e.size + 5) {
                        damageEnemy(e, stats.dmg * 2.0); // High damage fence
                        if(Math.random()<0.2*ts) createParticles(e.x, e.y, '#0ff', 2, 2);
                    }
                });
            }
        }
    }

    if(stats.forceField) {
        if(stats.forceFieldCd > 0) stats.forceFieldCd -= ts;
    }

    if(stats.nanoRepair && player.hp < player.maxHp * 0.3) {
        player.hp = Math.min(player.maxHp, player.hp + (50/60)*ts);
    }

    // --- Special Skills Logic ---
    if(stats.omegaLaser) {
        player.laserCd -= ts;
        if(player.laserCd <= 0) { fireOmegaLaser(); player.laserCd = 180; }
    }
    if(stats.absoluteZero) {
        enemies.forEach(e => {
            if(!e.dead && Math.hypot(e.x-player.x, e.y-player.y) < 250) {
                e.frozen = 5; 
            }
        });
        if(Math.random() < 0.2*ts && particles.length < MAX_PARTICLES) createParticles(player.x + (Math.random()-0.5)*500, player.y + (Math.random()-0.5)*500, '#88ffff', 1, 1);
    }
    if(stats.earthquake) {
        earthquakeTimer -= ts;
        if(earthquakeTimer <= 0) {
            earthquakeTimer = 120; // 2 seconds
            screenShake = 15; Sound.play('bash');
            enemies.forEach(e => { if(!e.dead) damageEnemy(e, stats.dmg * 2); });
            particles.push({type:'shockwave', x:player.x, y:player.y, size:400, life:30, color:'#f80'});
        }
    }
    if(stats.electroFence) {
        electroFenceTimer -= ts;
        if(electroFenceTimer <= 0) {
            electroFenceTimer = 60; // 1 second
            let r = 150;
            Sound.play('spark');
            particles.push({type:'shockwave', x:player.x, y:player.y, size:r, life:20, color:'#88ffff'});
            enemies.forEach(e => {
                if(!e.dead && Math.hypot(e.x-player.x, e.y-player.y) < r + e.size) {
                    damageEnemy(e, stats.dmg);
                    e.frozen = 30; // 0.5s stun
                    let ang = Math.atan2(e.y-player.y, e.x-player.x);
                    e.x += Math.cos(ang) * 30; e.y += Math.sin(ang) * 30; // Knockback
                    createLightningEffect(player.x, player.y, e.x, e.y);
                }
            });
        }
    }

    if(stats.orbital && Math.random() < 0.05 * ts) {
        let t = enemies[Math.floor(Math.random()*enemies.length)];
        if(t && !t.dead) {
            createParticles(t.x, t.y, '#f0f', 10, 3);
            damageEnemy(t, stats.dmg * 5);
            Sound.play('laser');
            particles.push({type:'shockwave', x:t.x, y:t.y, size:50, life:10, color:'#f0f'});
        }
    }

    if(Math.random() < (1/60) * ts && player.hp < player.maxHp) {
        player.hp = Math.min(player.maxHp, player.hp + stats.regen);
        updateUI();
    }

    let dx = 0, dy = 0;
    if(keys['w'] || keys['ArrowUp']) dy = -1;
    if(keys['s'] || keys['ArrowDown']) dy = 1;
    if(keys['a'] || keys['ArrowLeft']) dx = -1;
    if(keys['d'] || keys['ArrowRight']) dx = 1;

    if(joyTouchId !== null) { dx = joyMoveX; dy = joyMoveY; }

    if(dx!==0 || dy!==0) {
        let len = Math.hypot(dx, dy);
        if(len > 1) { dx/=len; dy/=len; }
        player.x += dx * stats.spd * ts;
        player.y += dy * stats.spd * ts;
        stats.isStationary = false;
        player.isMoving = true;
    } else {
        stats.isStationary = true;
        player.isMoving = false;
    }

    player.x = Math.max(15, Math.min(canvas.width-15, player.x));
    player.y = Math.max(15, Math.min(canvas.height-15, player.y));

    // Earth Shaker Effect
    if(stats.isEarthShaker && player.isMoving) {
        if(Math.floor(Date.now() / 200) % 2 === 0) { // Every 200ms
            screenShake = 2;
            enemies.forEach(e => {
                if(!e.dead && Math.hypot(e.x-player.x, e.y-player.y) < player.size + 40) {
                    damageEnemy(e, stats.dmg * 0.5); // Stomp damage
                    let pushAng = Math.atan2(e.y - player.y, e.x - player.x);
                    e.x += Math.cos(pushAng) * 10 * ts; e.y += Math.sin(pushAng) * 10 * ts; // Hard Push
                }
            });
        }
    }

    // --- Skills ---
    if(player.class === 'Melee' && (stats.multi > 0 || stats.bladeStorm)) {
        let count = stats.multi + (stats.bladeStorm ? 4 : 0);
        // Blade Master SubClass logic removed or adapted? 
        // Flying Swords Logic
        if(player.subClass === 'FlyingSwords') {
             if(flyingSwords.length !== count) {
                 // Reset
                 flyingSwords = [];
                 for(let i=0; i<count; i++) flyingSwords.push({x:player.x, y:player.y, target:null, cooldown:0});
             }
             
             flyingSwords.forEach(sw => {
                 if(sw.cooldown > 0) sw.cooldown -= ts;
                 
                 // Find Target if none
                 if(!sw.target || sw.target.dead || Math.hypot(sw.target.x-player.x, sw.target.y-player.y) > 400) {
                     sw.target = null;
                     let minD = 350;
                     enemies.forEach(e => {
                         if(e.dead) return;
                         let d = Math.hypot(e.x-player.x, e.y-player.y);
                         if(d < minD) { minD=d; sw.target=e; }
                     });
                 }
                 
                 let tx, ty;
                 if(sw.target) {
                     tx = sw.target.x; ty = sw.target.y;
                 } else {
                     // Orbit player if no target
                     let angle = Date.now() * 0.002 + (flyingSwords.indexOf(sw) * (Math.PI*2/count));
                     tx = player.x + Math.cos(angle) * 80;
                     ty = player.y + Math.sin(angle) * 80;
                 }
                 
                 // Move sword
                 sw.x += (tx - sw.x) * 0.15 * ts;
                 sw.y += (ty - sw.y) * 0.15 * ts;
                 
                 // Hit logic
                 enemies.forEach(e => {
                     if(!e.dead && Math.hypot(e.x-sw.x, e.y-sw.y) < 15 && sw.cooldown <= 0) {
                         damageEnemy(e, stats.dmg * 0.8);
                         createParticles(e.x, e.y, '#f0a', 1, 1);
                         sw.cooldown = 15; // Hit interval
                     }
                 });
             });

        } else {
            // Standard Orbit Logic
            if(spikeBits.length !== count) {
                spikeBits = []; for(let i=0; i<count; i++) spikeBits.push({angle:0});
            }
            let rotSpd = 0.1 * ts;
            spikeBits.forEach((bit, i) => {
                bit.angle += rotSpd;
                let currentAngle = bit.angle + (Math.PI*2/count)*i;
                let radius = 25 + player.size/2 + (stats.titan ? 20 : 0);
                if(stats.isColossus) radius += 20;
                
                bit.x = player.x + Math.cos(currentAngle) * radius;
                bit.y = player.y + Math.sin(currentAngle) * radius;
                enemies.forEach(e => {
                    if(!e.dead && Math.hypot(e.x-bit.x, e.y-bit.y) < 15 + e.size) {
                        if(Math.random() < 0.1 * ts) damageEnemy(e, stats.dmg * 0.5);
                    }
                });
            });
        }
    }

    if(stats.missile > 0) {
        // ★ 強化: 発射頻度向上
        if(Math.random() < (1 / (60 - stats.missile * 5)) * ts) fireMissile();
    }

    if(drones.length < stats.drones) {
        drones.push({ x: player.x, y: player.y, angle: Math.random()*Math.PI*2, state: 'orbit', target: null, timer: 0 });
    }
    let droneSpeedMult = stats.drones > 2 ? 1.5 : 1.0; 
    
    drones.forEach(d => {
        if(d.state === 'orbit') {
            d.angle += 0.05 * ts * droneSpeedMult;
            let ox = player.x + Math.cos(d.angle) * 80;
            let oy = player.y + Math.sin(d.angle) * 80;
            d.x += (ox - d.x) * 0.1 * ts; d.y += (oy - d.y) * 0.1 * ts;
            let minD = 350;
            enemies.forEach(e => {
                if(e.dead) return;
                let dist = Math.hypot(e.x - player.x, e.y - player.y);
                if(dist < minD) { minD = dist; d.target = e; d.state = 'attack'; }
            });
        } else if(d.state === 'attack') {
            if(!d.target || d.target.dead) { d.state = 'return'; return; }
            let ang = Math.atan2(d.target.y - d.y, d.target.x - d.x);
            d.x += Math.cos(ang) * 12 * ts * droneSpeedMult; d.y += Math.sin(ang) * 12 * ts * droneSpeedMult;
            if(Math.hypot(d.x - d.target.x, d.y - d.target.y) < 20) {
                damageEnemy(d.target, stats.dmg * 2);
                if(stats.lightning > 0) triggerLightning(d.target, stats.lightning);
                if(particles.length < MAX_PARTICLES) createParticles(d.x, d.y, '#ff0', 5, 2);
                d.state = 'return'; d.timer = 30 / droneSpeedMult; 
            }
        } else if(d.state === 'return') {
            d.timer -= ts;
            if(d.timer <= 0) {
                let ox = player.x + Math.cos(d.angle) * 80;
                let oy = player.y + Math.sin(d.angle) * 80;
                let ang = Math.atan2(oy - d.y, ox - d.x);
                d.x += Math.cos(ang) * 15 * ts; d.y += Math.sin(ang) * 15 * ts;
                if(Math.hypot(ox - d.x, oy - d.y) < 20) d.state = 'orbit';
            }
        }
    });

    if(stats.poison > 0 && Math.random() < (1/30)*ts) {
        gasClouds.push({ x: player.x, y: player.y, r: 30 + (stats.poison * 10), life: 180 + (stats.poison * 30), dmg: stats.dmg * (0.2 + stats.poison * 0.1) });
    }
    for(let i=gasClouds.length-1; i>=0; i--) {
        let g = gasClouds[i]; g.life -= ts;
        if(Math.random() < 0.1 * ts) { 
            enemies.forEach(e => { if(!e.dead && Math.hypot(e.x - g.x, e.y - g.y) < g.r + e.size) damageEnemy(e, g.dmg); }); 
        }
        if(g.life <= 0) gasClouds.splice(i, 1);
    }

    if(stats.spinBlade > 0) {
        let orbitalSpeed = (Date.now() / 1000) * 2;
        if(orbitals.length !== stats.spinBlade) { orbitals = []; for(let i=0; i<stats.spinBlade; i++) orbitals.push({}); }
        orbitals.forEach((orb, i) => {
            let angle = orbitalSpeed + (Math.PI * 2 / stats.spinBlade) * i;
            orb.x = player.x + Math.cos(angle) * 110; orb.y = player.y + Math.sin(angle) * 110;
            enemies.forEach(e => { 
                if(!e.dead && Math.hypot(e.x-orb.x, e.y-orb.y) < 20 + e.size && Math.random() < 0.12 * ts) damageEnemy(e, stats.dmg * 1.5); 
            });
        });
    }

    if(stats.aura) {
        let r = stats.auraRange * stats.auraScale;
        let auraRate = 0.1;
        if(player.class === 'Melee' && stats.homing > 0) auraRate += (stats.homing * 0.05);
        
        // Sun Crusher Logic
        if(player.subClass === 'SunCrusher') {
            if(player.isMoving) {
                // Release charge
                if(player.sunCharge > 0) {
                    player.sunCharge -= ts * 5; // Drain fast
                    r += player.sunCharge * 2; // Expand range based on charge
                    auraRate = 0.5; // High tick rate
                    // Add Damage Mod based on charge
                    if(Math.random() < 0.3) createParticles(player.x+(Math.random()-0.5)*r, player.y+(Math.random()-0.5)*r, '#fa0', 1, 3);
                }
            } else {
                // Charging
                player.sunCharge = Math.min(100, player.sunCharge + ts);
                r = 10; // Shrink when charging
                if(Math.random()<0.1) createParticles(player.x, player.y, '#fa0', 1, 1);
            }
        }

        enemies.forEach(e => { 
            if(e.dead) return;
            let dist = Math.hypot(e.x-player.x, e.y-player.y);
            if(dist < r + e.size) {
                if(Math.random() < auraRate * ts) {
                    let d = stats.dmg;
                    if(player.subClass === 'SunCrusher' && player.isMoving) d *= (1 + player.sunCharge/20);
                    damageEnemy(e, d);
                    
                    if(player.class === 'Melee' && stats.lightning > 0 && Math.random() < 0.3) {
                        triggerLightning(e, stats.lightning);
                    }
                }
                if(stats.gravityAura || stats.blackHole) {
                    let pull = (stats.blackHole ? 3.0 : 1.0) * ts; 
                    e.x += (player.x - e.x) / dist * pull;
                    e.y += (player.y - e.y) / dist * pull;
                    e.x -= Math.cos(Math.atan2(player.y-e.y, player.x-e.x)) * (e.speed*0.5) * ts; 
                    e.y -= Math.sin(Math.atan2(player.y-e.y, player.x-e.x)) * (e.speed*0.5) * ts;
                }
            } 
        });
    }

    // Guardian Siege Mode
    let currentRate = stats.rate;
    if(stats.siegeMode && stats.isStationary) currentRate /= 2;
    
    // Bullet Storm (Assault) Logic
    if(stats.bulletStorm) {
        // Always shoot fast, rate improves as you fire?
        // Simplified: Just very fast rate + high spread
        currentRate = 3; 
    }

    if(!stats.aura && Math.random() < (1/currentRate)*ts) {
        shoot();
        if(stats.chakram > 0 && Math.random() < 0.3) fireChakram();
    }

    // --- Bullets ---
    let boundary = 200; 
    for(let i=bullets.length-1; i>=0; i--) {
        let b = bullets[i];
        
        if(b.type === 'omega') {
            b.x += b.vx * ts; b.y += b.vy * ts; b.life -= ts;
            b.tick = (b.tick || 0) + ts;
            if(b.tick >= 5) {
                b.tick = 0;
                enemies.forEach(e => {
                    if(!e.dead && Math.abs(e.x - b.x) < b.size && Math.abs(e.y - b.y) < b.size) {
                        damageEnemy(e, stats.dmg * 5); 
                        if(particles.length < MAX_PARTICLES && Math.random() < 0.3) createParticles(e.x, e.y, '#f0f', 1, 1);
                    }
                });
            }
            if(b.life <= 0) { bullets.splice(i,1); }
            continue;
        }

        if(b.type === 'chakram') {
            b.x += b.vx * ts; b.y += b.vy * ts; b.life -= ts; 
            if(b.life <= 0) { bullets.splice(i, 1); continue; }
            if(b.x < 0 || b.x > canvas.width) { b.vx *= -1; b.x = Math.max(0, Math.min(canvas.width, b.x)); Sound.play('bounce'); }
            if(b.y < 0 || b.y > canvas.height) { b.vy *= -1; b.y = Math.max(0, Math.min(canvas.height, b.y)); Sound.play('bounce'); }
            for(let j=enemies.length-1; j>=0; j--) {
                let e = enemies[j];
                if(e.dead || b.hit.includes(e.id)) continue;
                if(Math.hypot(b.x-e.x, b.y-e.y) < b.size + e.size) {
                    damageEnemy(e, stats.dmg * 1.5);
                    if(particles.length < MAX_PARTICLES) createParticles(b.x, b.y, '#0ff', 2, 2);
                    if(b.bounceCd <= 0) {
                        let ang = Math.atan2(b.y - e.y, b.x - e.x); 
                        let spd = Math.hypot(b.vx, b.vy);
                        b.vx = Math.cos(ang) * spd; b.vy = Math.sin(ang) * spd;
                        b.bounceCd = 10;
                        Sound.play('bounce');
                    }
                }
            }
            if(b.bounceCd > 0) b.bounceCd -= ts;
            if(Math.random()<0.3 && particles.length < MAX_PARTICLES) createParticles(b.x, b.y, '#8ff', 1, 1);
            continue;
        }
        
        if(b.type !== 'missile' && stats.homing > 0) {
            let detectRange = 250 + (stats.homing * 50); 
            let target = null, minD = detectRange;
            enemies.forEach(e => { if(e.dead) return; let d = Math.hypot(e.x-b.x, e.y-b.y); if(d < minD && !b.hit.includes(e.id)) { minD = d; target = e; } });
            
            if(target) {
                let desiredAngle = Math.atan2(target.y - b.y, target.x - b.x);
                let currentAngle = Math.atan2(b.vy, b.vx);
                let turnSpeed = (0.05 + (stats.homing * 0.05)) * ts; 
                let diff = desiredAngle - currentAngle;
                if(diff > Math.PI) diff -= Math.PI*2; if(diff < -Math.PI) diff += Math.PI*2;
                if(Math.abs(diff) < Math.PI) {
                    currentAngle += Math.sign(diff) * Math.min(Math.abs(diff), turnSpeed);
                    let speed = Math.hypot(b.vx, b.vy);
                    b.vx = Math.cos(currentAngle) * speed; b.vy = Math.sin(currentAngle) * speed;
                }
            }
        }

        if(b.type === 'missile' || b.type === 'spirit') {
            let minD = 400, target = null;
            enemies.forEach(e => { if(e.dead) return; let d = Math.hypot(e.x-b.x, e.y-b.y); if(d < minD) { minD=d; target=e; } });
            if(target) {
                let ang = Math.atan2(target.y - b.y, target.x - b.x);
                let cur = Math.atan2(b.vy, b.vx);
                let diff = ang - cur;
                if(diff > Math.PI) diff -= Math.PI*2; if(diff < -Math.PI) diff += Math.PI*2;
                cur += Math.sign(diff) * 0.1 * ts;
                b.vx = Math.cos(cur) * b.speed; b.vy = Math.sin(cur) * b.speed;
            }
            b.x += b.vx * ts; b.y += b.vy * ts; 
            if(Math.random() < 0.5 * ts && particles.length < MAX_PARTICLES) createParticles(b.x, b.y, b.type==='spirit'?'#8f8':'#f80', 1, 2);
        } else {
            // Normal bullets
            b.x += b.vx * ts; b.y += b.vy * ts;
            if(b.life !== undefined) {
                b.life -= ts;
                if(b.life <= 0) { bullets.splice(i, 1); continue; }
            }

            // Ghost Shot Logic (Screen Wrap + Power Up)
            if(stats.ghostShot) {
                let wrapped = false;
                if(b.x < 0) { b.x = canvas.width; wrapped=true; }
                else if(b.x > canvas.width) { b.x = 0; wrapped=true; }
                if(b.y < 0) { b.y = canvas.height; wrapped=true; }
                else if(b.y > canvas.height) { b.y = 0; wrapped=true; }

                if(wrapped) {
                    b.size = Math.min(50, b.size * 1.5); // Grow
                    b.damageMult = (b.damageMult || 1) * 1.5; // Damage up
                    b.pierce = 999; // Reset pierce effectively
                }
            }
        }

        if(stats.shotBounce && (b.type === 'normal')) {
            if(b.x < 0 || b.x > canvas.width) { b.vx *= -1; b.x = Math.max(0, Math.min(canvas.width, b.x)); Sound.play('bounce'); }
            if(b.y < 0 || b.y > canvas.height) { b.vy *= -1; b.y = Math.max(0, Math.min(canvas.height, b.y)); Sound.play('bounce'); }
        }
        
        // Remove if out of bounds (unless ghost)
        if(!stats.ghostShot && (b.x < -boundary || b.x > canvas.width+boundary || b.y < -boundary || b.y > canvas.height+boundary)) { bullets.splice(i, 1); continue; }

        let hit = false;
        for(let j=enemies.length-1; j>=0; j--) {
            let e = enemies[j];
            if(e.dead || b.hit.includes(e.id)) continue;
            
            let bulletHitSize = (player.class === 'Sniper' && b.type === 'normal') ? b.size + 15 : b.size;
            if(stats.titan) bulletHitSize *= 1.5;

            if(Math.hypot(b.x-e.x, b.y-e.y) < bulletHitSize + e.size) {
                if(b.type === 'missile') {
                    Sound.play('explode');
                    particles.push({type:'shockwave', x:b.x, y:b.y, size:10, life:15, color:'#f80'});
                    let blastR = 100 * stats.missileBlast;
                    let blastDmg = stats.dmg * 3 * stats.missileBlast;
                    enemies.forEach(subE => { 
                        if(!subE.dead && Math.hypot(subE.x - b.x, subE.y - b.y) < blastR) {
                            damageEnemy(subE, blastDmg);
                            if(stats.napalm && Math.random()<0.5) gasClouds.push({x:subE.x, y:subE.y, r:30, life:120, dmg:stats.dmg*0.2});
                        }
                    });
                    if(particles.length < MAX_PARTICLES) createParticles(b.x, b.y, '#f00', 10 * stats.missileBlast, 5 * stats.missileBlast);
                    bullets.splice(i, 1); hit = true; break;
                } else {
                    let finalDmg = stats.dmg * (b.damageMult || 1);
                    damageEnemy(e, finalDmg);
                    
                    if(stats.knockback > 0 && !b.isMini) {
                        let ang = Math.atan2(e.y - player.y, e.x - player.x);
                        e.x += Math.cos(ang) * stats.knockback * 20;
                        e.y += Math.sin(ang) * stats.knockback * 20;
                    }
                    
                    // Cluster Striker Logic
                    if(stats.clusterStriker && !b.isMini) {
                         // Spawn mini bombs
                         Sound.play('explode', 2.0);
                         for(let k=0; k<6; k++) {
                             let ang = (Math.PI*2/6)*k;
                             bullets.push({type:'missile', x:e.x, y:e.y, vx:Math.cos(ang)*5, vy:Math.sin(ang)*5, size:4, speed:0, hit:[e.id], isMini:true});
                         }
                    }

                    // Prism Shooter Split Logic
                    if(stats.prismSplit && !b.isMini && (b.splitCount || 0) < 2) {
                        for(let k=0; k<2; k++) {
                             let ang = Math.atan2(b.vy, b.vx) + (k===0 ? 0.5 : -0.5);
                             bullets.push({
                                 type:'normal', x:e.x, y:e.y, 
                                 vx:Math.cos(ang)*stats.bulletSpeed, vy:Math.sin(ang)*stats.bulletSpeed, 
                                 size:b.size*0.8, hit:[e.id], pierce:0, isMini:false, color:'#f0f',
                                 splitCount: (b.splitCount||0)+1
                             });
                        }
                    }

                    if(stats.absoluteZero && Math.random()<0.3) e.frozen = 60; 
                    if(stats.shotExplode) { 
                        Sound.play('explode', 2.0);
                        enemies.forEach(subE => { if(!subE.dead && Math.hypot(subE.x-e.x, subE.y-e.y) < 50) damageEnemy(subE, stats.dmg*0.5); });
                        createParticles(e.x, e.y, '#fa0', 3, 2);
                    }
                    if(stats.napalm && Math.random()<0.2) gasClouds.push({x:e.x, y:e.y, r:20, life:100, dmg:stats.dmg*0.2});
                    
                    if(stats.splitShot && !b.isMini) { 
                        for(let k=0; k<2; k++) {
                            let ang = (Math.random()*Math.PI*2);
                            bullets.push({type:'normal', x:e.x, y:e.y, vx:Math.cos(ang)*10, vy:Math.sin(ang)*10, size:3, hit:[e.id], pierce:0, isMini:true});
                        }
                    }

                    if(stats.lightning > 0) triggerLightning(e, stats.lightning);
                    b.hit.push(e.id);
                    if(particles.length < MAX_PARTICLES) createParticles(b.x, b.y, '#ffffaa', 3, 2); 
                    
                    if(b.pierce <= 0 && !stats.infinitePierce) { bullets.splice(i, 1); hit = true; break; } 
                    else { b.pierce--; }
                }
            }
        }
        if(hit) continue;
    }

    for(let i=enemyBullets.length-1; i>=0; i--) {
        let b = enemyBullets[i];
        b.x += b.vx * ts; b.y += b.vy * ts;
        if(b.x < -100 || b.x > canvas.width+100 || b.y < -100 || b.y > canvas.height+100) { enemyBullets.splice(i, 1); continue; }
        if(Math.hypot(player.x-b.x, player.y-b.y) < player.size + b.size) { 
            let dmg = 10 + Math.floor(level * 0.5);
            takeDamage(dmg); 
            enemyBullets.splice(i, 1); 
        }
    }

    if(enemies.length < MAX_ENEMIES) {
        let spawnDenom = Math.max(5, 25 - (level * 0.6)); 
        let hordeMult = 1.0;
        if (level >= 5) {
            let progress = Math.min(1.0, (level - 5) / 25);
            hordeMult = 2.0 + progress; 
        }
        if (singularityMode) hordeMult *= 3.0;

        let spawnProb = (hordeMult / spawnDenom) * ts;
        if(player.hp >= player.maxHp * 0.9) {
            spawnProb *= 3.0; 
        }

        if(Math.random() < spawnProb) spawnEnemy('random', gameTimeSec);
    }

    let cycleTime = gameTimeSec % 300; 
    let cycleWave = Math.floor(gameTimeSec / 300);

    if(cycleTime > 295 && !bossWarningActive && cycleWave === bossCycleCounter) {
        bossWarningActive = true;
        triggerWarning();
    }
    if(cycleWave > bossCycleCounter) {
        bossCycleCounter = cycleWave;
        bossWarningActive = false;
        document.getElementById('warning-overlay').style.display = 'none';
        spawnEnemy('boss', gameTimeSec); 
    }

    enemies.forEach(e => {
        if(e.dead) return;
        
        if(e.frozen > 0) { 
            e.frozen -= ts;
            if(Math.random()<0.1 && particles.length < MAX_PARTICLES) createParticles(e.x, e.y, '#88ffff', 1, 1);
        } else {
            let dist = Math.hypot(player.x - e.x, player.y - e.y);
            let angle = Math.atan2(player.y - e.y, player.x - e.x);
            if (e.flash > 0) e.flash -= ts;
            
            if(e.ai === 'dasher') {
                if(e.state === 'chase') {
                    e.x += Math.cos(angle) * e.speed * ts; e.y += Math.sin(angle) * e.speed * ts;
                    if(dist < 250) { e.state = 'aim'; e.timer = 30; } 
                } else if(e.state === 'aim') {
                    e.timer -= ts; if(e.timer <= 0) { e.state = 'dash'; e.timer = 30; e.vx = Math.cos(angle) * 14; e.vy = Math.sin(angle) * 14; }
                } else if(e.state === 'dash') {
                    e.x += e.vx * ts; e.y += e.vy * ts; e.timer -= ts; 
                    if(Math.random() < 0.5 * ts && particles.length < MAX_PARTICLES) createParticles(e.x, e.y, '#f80', 1, 2);
                    if(e.timer <= 0) { e.state = 'cooldown'; e.timer = 50; }
                } else if(e.state === 'cooldown') { e.timer -= ts; e.x += Math.cos(angle) * (e.speed * 0.2) * ts; if(e.timer <= 0) e.state = 'chase'; }
            } else if(e.ai === 'shooter') {
                if(dist > 250) { e.x += Math.cos(angle) * e.speed * ts; e.y += Math.sin(angle) * e.speed * ts; }
                else if(dist < 150) { e.x -= Math.cos(angle) * e.speed * 0.5 * ts; e.y -= Math.sin(angle) * e.speed * 0.5 * ts; }
                if(Math.random() < (1/120)*ts && dist < 600) { enemyBullets.push({x: e.x, y: e.y, vx: Math.cos(angle)*6, vy: Math.sin(angle)*6, size: 6, color: '#f0a'}); }
            } else if(e.ai === 'bat') {
                let zig = Math.sin(gameTimeSec * 5) * 0.8;
                e.x += Math.cos(angle + zig) * e.speed * ts; e.y += Math.sin(angle + zig) * e.speed * ts;
            } else {
                e.x += Math.cos(angle) * e.speed * ts; e.y += Math.sin(angle) * e.speed * ts;
            }

            if(dist < player.size + e.size) {
                if(stats.spikeArmor && Math.random() < 0.2 * ts) {
                    damageEnemy(e, stats.dmg * 0.5);
                    if(particles.length < MAX_PARTICLES) createParticles((player.x+e.x)/2, (player.y+e.y)/2, '#fff', 1, 2);
                }
                if(stats.spikeReflect) { 
                    damageEnemy(e, e.dmg * 2.0);
                    Sound.play('hit');
                }
                
                // Earth Shaker Collision
                if(stats.isEarthShaker) {
                    damageEnemy(e, stats.dmg * 2); // Body slam damage
                    Sound.play('bash');
                    let kickAng = Math.atan2(e.y - player.y, e.x - player.x);
                    e.x += Math.cos(kickAng) * 30; e.y += Math.sin(kickAng) * 30;
                }

                if(player.class === 'Melee' && player.slamCd <= 0) {
                    let cd = Math.max(10, 60 - stats.rate);
                    player.slamCd = cd; 
                    damageEnemy(e, stats.dmg * 2 * (player.size/15)); 
                    let waveSize = 15 + (stats.pierce * 5); 
                    Sound.play('bash');
                    if(particles.length < MAX_PARTICLES) createParticles(e.x, e.y, '#fff', 5, 2);
                    particles.push({type:'shockwave', x:player.x, y:player.y, size:waveSize, life:10, color:'#f00'});
                    enemies.forEach(subE => {
                        if(!subE.dead && Math.hypot(subE.x - player.x, subE.y - player.y) < waveSize * 3) {
                            damageEnemy(subE, stats.dmg * 0.5);
                        }
                    });
                } else {
                    let contactDmg = e.dmg; 
                    takeDamage(contactDmg);
                }
            }
        }
    });
    
    enemies = enemies.filter(e => !e.dead);

    // ★ XP Orbs & Magnet Logic Fix
    if(expOrbs.length > MAX_ORBS) {
        let removed = expOrbs.splice(0, expOrbs.length - MAX_ORBS);
        // ★ 100% Auto Collect
        removed.forEach(o => { if(gameActive) addExp(o.val, true); });
    }
    for(let i=expOrbs.length-1; i>=0; i--) {
        if(!gameActive) break; 
        let o = expOrbs[i];
        
        let d = Math.hypot(player.x - o.x, player.y - o.y);

        if(o.forceCollect) {
            o.x += (player.x - o.x) * 0.2 * ts; 
            o.y += (player.y - o.y) * 0.2 * ts;
        } else if(d < stats.magnet) {
            o.x += (player.x - o.x) * 0.25 * ts; 
            o.y += (player.y - o.y) * 0.25 * ts; 
        }
        
        if(d < 20) { addExp(o.val); Sound.play('exp', o.pitch); expOrbs.splice(i, 1); }
    }

    for(let i=items.length-1; i>=0; i--) {
        let it = items[i];
        let d = Math.hypot(player.x - it.x, player.y - it.y);
        if(d < 200) {
            it.x += (player.x - it.x) * 0.1 * ts;
            it.y += (player.y - it.y) * 0.1 * ts;
        }
        if(d < 30) {
            if(it.type === 'magnet') {
                Sound.play('powerup');
                particles.push({type:'shockwave', x:player.x, y:player.y, size:500, life:30, color:'#fff'});
                expOrbs.forEach(o => o.forceCollect = true);
            }
            items.splice(i, 1);
        }
    }

    if(particles.length > MAX_PARTICLES) particles.splice(0, particles.length - MAX_PARTICLES);
    for(let i=particles.length-1; i>=0; i--) {
        let p = particles[i];
        if(p.type === 'lightning') { p.life -= ts; } 
        else if(p.type === 'shockwave') { p.size += 3 * ts; p.life -= ts; } 
        else { p.x += p.vx * ts; p.y += p.vy * ts; p.life -= ts; p.size *= 0.9; }
        if(p.life <= 0) particles.splice(i, 1);
    }
    
    if(texts.length > MAX_TEXTS) texts.splice(0, texts.length - MAX_TEXTS);
    for(let i=texts.length-1; i>=0; i--) {
        texts[i].y -= 1 * ts; texts[i].life -= ts;
        if(texts[i].life<=0) texts.splice(i, 1);
    }
}

function shoot() {
    let target = null;
    let minD = Infinity;
    
    enemies.forEach(e => {
        if (e.dead) return;
        let d = Math.hypot(e.x - player.x, e.y - player.y);
        if (d < minD) { minD = d; target = e; }
    });

    let angle;
    if (target) { angle = Math.atan2(target.y - player.y, target.x - player.x); } 
    else { angle = Math.random() * Math.PI * 2; }

    let count = stats.multi;
    if(player.class === 'Sniper') count = 1; 
    if(stats.infiniteMag) count += 3; 
    
    // Guardian Siege Mode
    let currentDmg = stats.dmg;
    if(stats.siegeMode && stats.isStationary) currentDmg *= 2;

    if(stats.doubleShot && Math.random() < 0.5) count *= 2; 

    let spread = 0.1;
    if(stats.bulletStorm) {
        spread = 0.5 + Math.sin(Date.now()*0.01)*0.5; // Chaos spread
        count += 3; // Extra bullets
    }
    let startAngle = angle - (spread * (count-1)) / 2;

    for(let i=0; i<count; i++) {
        let currentAngle = startAngle + spread * i;
        let vx = Math.cos(currentAngle) * stats.bulletSpeed;
        let vy = Math.sin(currentAngle) * stats.bulletSpeed;
        
        let bType = 'normal';
        bullets.push({
            type: bType,
            x: player.x,
            y: player.y,
            vx: vx,
            vy: vy,
            size: stats.railgun ? 10 : 5,
            color: stats.ghostShot ? '#88ff88' : (stats.prismSplit ? '#f0f' : '#fff'),
            hit: [],
            pierce: stats.pierce,
            isMini: false
        });
    }

    if(stats.missileChance > 0 && Math.random() < stats.missileChance) { 
        fireMissile();
    }

    Sound.play('shoot', 1.0 + Math.random()*0.2);
}

function dash() {
    if(player.dashCd > 0) return;
    player.dashCd = player.maxDashCd;
    player.invincible = 30; // 0.5s invincible
    
    let dx = 0, dy = 0;
    if(keys['w'] || keys['ArrowUp']) dy = -1;
    if(keys['s'] || keys['ArrowDown']) dy = 1;
    if(keys['a'] || keys['ArrowLeft']) dx = -1;
    if(keys['d'] || keys['ArrowRight']) dx = 1;
    
    if(joyTouchId !== null) { dx = joyMoveX; dy = joyMoveY; }
    
    if(dx === 0 && dy === 0) dx = 1; 

    let len = Math.hypot(dx, dy);
    if(len > 0) { dx /= len; dy /= len; }

    player.x += dx * 100;
    player.y += dy * 100;
    player.x = Math.max(15, Math.min(canvas.width-15, player.x));
    player.y = Math.max(15, Math.min(canvas.height-15, player.y));
    
    if(stats.clusterMine) {
         for(let i=0; i<3; i++) {
             let mx = player.x - dx * (20 + i*10);
             let my = player.y - dy * (20 + i*10);
             bullets.push({type:'missile', x:mx, y:my, vx:0, vy:0, speed:0, size:5, hit:[], isMini:false});
         }
    }

    createParticles(player.x, player.y, '#fff', 10, 2);
    Sound.play('dash'); 
}

function spawnSentry() {
    if(sentries.length >= stats.sentryMax) sentries.shift(); // Use max limit
    sentries.push({x: player.x, y: player.y, cooldown: 0});
    createParticles(player.x, player.y, '#0f0', 10, 3);
    Sound.play('spark');
}

function pointToLineDistance(px, py, x1, y1, x2, y2) {
    let A = px - x1; let B = py - y1;
    let C = x2 - x1; let D = y2 - y1;
    let dot = A * C + B * D;
    let len_sq = C * C + D * D;
    let param = -1;
    if (len_sq !== 0) param = dot / len_sq;
    let xx, yy;
    if (param < 0) { xx = x1; yy = y1; }
    else if (param > 1) { xx = x2; yy = y2; }
    else { xx = x1 + param * C; yy = y1 + param * D; }
    let dx = px - xx; let dy = py - yy;
    return Math.hypot(dx, dy);
}

function fireMissile() {
    Sound.play('missile');
    bullets.push({ type: 'missile', x: player.x, y: player.y, vx: (Math.random()-0.5)*4, vy: -5, speed: 10, size: 8, hit: [], isMini: false });
}

function fireOmegaLaser() {
    Sound.play('laser');
    screenShake = 10;
    bullets.push({ type: 'omega', x: player.x, y: player.y, vx: 50, vy: 0, size: 300, life: 30, hit: [], tick: 0 });
    particles.push({type:'shockwave', x:player.x, y:player.y, size:100, life:20, color:'#f0f'});
}

function fireChakram() {
    let ang = Math.random() * Math.PI * 2;
    bullets.push({ 
        type: 'chakram', x: player.x, y: player.y, 
        vx: Math.cos(ang)*12, vy: Math.sin(ang)*12, 
        size: 10 + stats.chakram*2, life: 180 + stats.chakram*30, 
        hit: [], bounceCd: 0 
    });
}

function triggerLightning(target, lv) {
    let range = 200 + (lv * 30); let count = 0; let maxTargets = lv; 
    enemies.forEach(e => {
        if(!e.dead && e !== target && count < maxTargets) {
            if(Math.hypot(e.x - target.x, e.y - target.y) < range) {
                damageEnemy(e, stats.dmg * 0.8);
                createLightningEffect(target.x, target.y, e.x, e.y);
                Sound.play('lightning'); count++;
            }
        }
    });
}
function createLightningEffect(x1, y1, x2, y2) { 
    if(particles.length > MAX_PARTICLES) return;
    particles.push({ type: 'lightning', x1: x1, y1: y1, x2: x2, y2: y2, life: 10, color: '#88ffff' }); 
}

function takeDamage(dmg) {
    if(stats.forceField && stats.forceFieldCd <= 0) {
        stats.forceFieldCd = 300; 
        Sound.play('bounce');
        particles.push({type:'shockwave', x:player.x, y:player.y, size:50, life:20, color:'#0ff'});
        return; 
    }
    
    if(player.invincible > 0) return;
    
    dmg = Math.max(1, dmg - stats.armor);

    player.hp -= dmg; 
    player.invincible = 20; 
    screenShake = 15;
    createParticles(player.x, player.y, '#f00', 10, 4); updateUI();
    
    if(stats.reactiveArmor) {
        Sound.play('spark');
        particles.push({type:'shockwave', x:player.x, y:player.y, size:150, life:10, color:'#0f0'});
        enemies.forEach(e => {
             if(!e.dead && Math.hypot(e.x - player.x, e.y - player.y) < 150) {
                 damageEnemy(e, stats.dmg);
                 let ang = Math.atan2(e.y - player.y, e.x - player.x);
                 e.x += Math.cos(ang) * 50; e.y += Math.sin(ang) * 50; 
             }
        });
    }

    if(player.hp <= 0) gameOver();
}

function draw() {
    let shakeX = (Math.random() - 0.5) * screenShake;
    let shakeY = (Math.random() - 0.5) * screenShake;
    ctx.save(); ctx.translate(shakeX, shakeY);

    ctx.fillStyle = '#050505'; ctx.fillRect(-20, -20, canvas.width+40, canvas.height+40);
    
    ctx.strokeStyle = '#1a1a1a'; ctx.lineWidth = 1; ctx.beginPath();
    for(let i=0; i<canvas.width; i+=100) { ctx.moveTo(i,0); ctx.lineTo(i,canvas.height); }
    for(let i=0; i<canvas.height; i+=100) { ctx.moveTo(0,i); ctx.lineTo(canvas.width,i); }
    ctx.stroke();

    if(stats.absoluteZero) {
        ctx.fillStyle = 'rgba(0, 255, 255, 0.05)';
        ctx.beginPath(); ctx.arc(player.x, player.y, 250, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)'; ctx.lineWidth=1; ctx.stroke();
    }
    // New: Electro Fence Vis
    if(stats.electroFence) {
        ctx.strokeStyle = `rgba(136, 255, 255, ${(electroFenceTimer/60)})`;
        ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(player.x, player.y, 150, 0, Math.PI*2); ctx.stroke();
    }

    gasClouds.forEach(g => { ctx.fillStyle = `rgba(100, 0, 150, ${g.life/100})`; ctx.beginPath(); ctx.arc(g.x, g.y, g.r, 0, Math.PI*2); ctx.fill(); });

    // Sentries
    sentries.forEach(s => {
        ctx.fillStyle = '#0f0'; ctx.fillRect(s.x-10, s.y-10, 20, 20);
        ctx.strokeStyle = '#fff'; ctx.lineWidth=2; ctx.strokeRect(s.x-10, s.y-10, 20, 20);
    });
    // Tesla Grid Lines
    if(stats.teslaGrid && sentries.length >= 2) {
        ctx.strokeStyle = '#0ff'; ctx.lineWidth = 3; ctx.shadowBlur = 10; ctx.shadowColor='#0ff';
        ctx.beginPath();
        ctx.moveTo(sentries[0].x, sentries[0].y);
        for(let i=1; i<sentries.length; i++) ctx.lineTo(sentries[i].x, sentries[i].y);
        ctx.lineTo(sentries[0].x, sentries[0].y);
        ctx.stroke();
        ctx.shadowBlur = 0;
    }

    if(player.class === 'Melee' && flyingSwords.length > 0) {
        ctx.fillStyle = '#f0a';
        flyingSwords.forEach(sw => {
            ctx.save(); ctx.translate(sw.x, sw.y); ctx.rotate(Date.now()*0.1);
            ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(5, 5); ctx.lineTo(-5, 5); ctx.fill();
            ctx.restore();
            // Trail
            ctx.strokeStyle = 'rgba(255, 0, 100, 0.3)'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(player.x, player.y); ctx.lineTo(sw.x, sw.y); ctx.stroke();
        });
    }

    if(player.class === 'Melee' && spikeBits.length > 0) {
        ctx.fillStyle = '#f00';
        spikeBits.forEach(bit => {
            ctx.beginPath(); ctx.moveTo(bit.x, bit.y - 8); ctx.lineTo(bit.x + 6, bit.y + 6); ctx.lineTo(bit.x - 6, bit.y + 6); ctx.fill();
        });
    }

    if(stats.aura) {
        ctx.save(); ctx.translate(player.x, player.y); ctx.rotate(Date.now() * 0.005);
        let r = stats.auraRange * stats.auraScale;
        let auraColor = '0, 255, 255';
        if(player.subClass === 'SunCrusher') {
            auraColor = '255, 100, 0'; // Magma
            if(player.isMoving) r += player.sunCharge * 2;
        }

        let grad = ctx.createRadialGradient(0, 0, r*0.5, 0, 0, r);
        grad.addColorStop(0, `rgba(${auraColor}, 0)`); grad.addColorStop(0.8, `rgba(${auraColor}, 0.2)`);
        if(stats.gravityAura) grad.addColorStop(0.9, 'rgba(100, 0, 200, 0.4)'); 
        if(stats.blackHole) { grad.addColorStop(1, 'rgba(0, 0, 0, 0.6)'); ctx.strokeStyle='#f0f'; } 
        else ctx.strokeStyle = `rgba(${auraColor}, 0.5)`;
        
        ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();
        ctx.lineWidth = 2;
        ctx.beginPath(); for(let i=0; i<3; i++) { ctx.rotate(Math.PI*2/3); ctx.moveTo(r * 0.6, 0); ctx.lineTo(r, 0); }
        ctx.stroke(); ctx.restore();
    }

    ctx.fillStyle = '#0ff';
    orbitals.forEach(o => { ctx.beginPath(); ctx.arc(o.x, o.y, 8, 0, Math.PI*2); ctx.fill(); });
    
    drones.forEach(d => {
        ctx.save(); ctx.translate(d.x, d.y); ctx.rotate(Date.now() * 0.01);
        ctx.fillStyle = '#ff0'; ctx.fillRect(-6, -6, 12, 12);
        ctx.strokeStyle = '#fff'; ctx.strokeRect(-6, -6, 12, 12);
        ctx.restore();
    });

    // Force Field Vis
    if(stats.forceField && stats.forceFieldCd <= 0) {
        ctx.strokeStyle = `rgba(0, 255, 255, 0.8)`; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(player.x, player.y, player.size + 10, 0, Math.PI*2); ctx.stroke();
    }

    // ★ Draw Items
    items.forEach(it => {
        if(it.type === 'magnet') {
            ctx.save(); ctx.translate(it.x, it.y);
            let s = 1.0 + Math.sin(Date.now()*0.01)*0.2;
            ctx.scale(s, s);
            ctx.font = '24px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline='middle';
            ctx.fillText('🧲', 0, 0);
            ctx.restore();
        }
    });

    if(player.invincible % 10 < 5) {
        ctx.shadowBlur = 30; ctx.shadowColor = player.color; ctx.fillStyle = player.color;
        ctx.beginPath(); ctx.arc(player.x, player.y, player.size, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(player.x, player.y, player.size*0.6, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0;
    }

    bullets.forEach(b => { 
        if(b.type === 'omega') {
            ctx.fillStyle = `rgba(255, 0, 255, ${b.life/30})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff'; ctx.fillRect(0, b.y - 50, canvas.width, 100);
        }
        else if(b.type === 'missile') {
            ctx.fillStyle = '#f80'; ctx.beginPath(); ctx.moveTo(b.x, b.y-8); ctx.lineTo(b.x+6, b.y+6); ctx.lineTo(b.x-6, b.y+6); ctx.fill();
        } else if(b.type === 'chakram') {
            ctx.fillStyle = '#0ff'; ctx.save(); ctx.translate(b.x, b.y); ctx.rotate(Date.now() * 0.2);
            ctx.fillRect(-b.size/2, -b.size/2, b.size, b.size); ctx.restore();
        } else if(b.type === 'spirit') {
            ctx.fillStyle = '#8f8'; ctx.beginPath(); ctx.arc(b.x, b.y, 6, 0, Math.PI*2); ctx.fill();
        } else {
            let drawSize = (player.class === 'Sniper' && b.type === 'normal') ? 8 : b.size;
            if(b.isMini) drawSize = 2;
            ctx.fillStyle = b.color; ctx.beginPath(); ctx.arc(b.x, b.y, drawSize, 0, Math.PI*2); ctx.fill(); 
        }
    });
    
    ctx.shadowBlur = 10; ctx.shadowColor = '#f00'; 
    ctx.fillStyle = '#fff'; 
    enemyBullets.forEach(b => { ctx.beginPath(); ctx.arc(b.x, b.y, b.size, 0, Math.PI*2); ctx.fill(); });
    ctx.shadowBlur = 0;

    enemies.forEach(e => {
        ctx.fillStyle = e.frozen > 0 ? '#0ff' : (e.flash > 0 ? '#fff' : e.color); 
        ctx.beginPath();
        if(e.type === 'boss') {
            ctx.shadowBlur = 20; ctx.shadowColor = 'red'; ctx.fillRect(e.x-e.size, e.y-e.size, e.size*2, e.size*2); ctx.shadowBlur = 0;
            ctx.fillStyle = 'red'; ctx.fillRect(e.x-40, e.y-e.size-20, 80, 8); ctx.fillStyle = '#0f0'; ctx.fillRect(e.x-40, e.y-e.size-20, 80*(e.hp/e.maxHp), 8);
        } else if(e.type === 'golem') {
            // Golem: Square shape
            ctx.fillRect(e.x-e.size, e.y-e.size, e.size*2, e.size*2);
            ctx.strokeStyle = '#000'; ctx.lineWidth = 2; ctx.strokeRect(e.x-e.size, e.y-e.size, e.size*2, e.size*2);
        } else {
            if(e.ai === 'dasher') { ctx.moveTo(e.x, e.y-e.size); ctx.lineTo(e.x+e.size, e.y+e.size); ctx.lineTo(e.x-e.size, e.y+e.size); ctx.closePath(); }
            else if(e.ai === 'splitter') { ctx.rect(e.x-e.size, e.y-e.size, e.size*2, e.size*2); }
            else if(e.ai === 'bat') { ctx.moveTo(e.x, e.y-e.size); ctx.lineTo(e.x+e.size, e.y); ctx.lineTo(e.x, e.y+e.size); ctx.lineTo(e.x-e.size, e.y); ctx.closePath(); }
            else if(e.ai === 'shooter') { ctx.rect(e.x-e.size, e.y-e.size, e.size*2, e.size*2); }
            else if(e.ai === 'tank') { for(let i=0; i<6; i++) { let ang = i * Math.PI / 3; let px = e.x + Math.cos(ang) * e.size; let py = e.y + Math.sin(ang) * e.size; if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py); } ctx.closePath(); }
            else { ctx.arc(e.x, e.y, e.size, 0, Math.PI*2); }
            ctx.fill();
        }
    });

    expOrbs.forEach(o => { ctx.fillStyle = o.color; ctx.beginPath(); ctx.arc(o.x, o.y, o.size, 0, Math.PI*2); ctx.fill(); });
    
    particles.forEach(p => {
        if(p.type === 'lightning') {
            ctx.strokeStyle = p.color; ctx.lineWidth = 3; ctx.shadowBlur = 10; ctx.shadowColor = p.color; ctx.globalAlpha = p.life / 10;
            ctx.beginPath(); ctx.moveTo(p.x1, p.y1);
            let midX = (p.x1 + p.x2) / 2 + (Math.random()-0.5)*30; let midY = (p.y1 + p.y2) / 2 + (Math.random()-0.5)*30;
            ctx.lineTo(midX, midY); ctx.lineTo(p.x2, p.y2); ctx.stroke(); ctx.globalAlpha = 1.0; ctx.shadowBlur = 0;
        } else if(p.type === 'shockwave') {
            ctx.strokeStyle = p.color; ctx.lineWidth = 3; ctx.globalAlpha = p.life/15;
            ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.stroke(); ctx.globalAlpha=1;
        } else {
            ctx.fillStyle = p.color; ctx.globalAlpha = p.life / 20; ctx.fillRect(p.x, p.y, p.size, p.size); ctx.globalAlpha = 1.0;
        }
    });

    ctx.font = 'bold 16px sans-serif';
    texts.forEach(t => { ctx.fillStyle = t.color || 'white'; ctx.fillText(t.str, t.x, t.y); });

    ctx.restore();
    let grad = ctx.createRadialGradient(player.x, player.y, 100, player.x, player.y, 800);
    grad.addColorStop(0, 'rgba(0,0,0,0)'); grad.addColorStop(1, 'rgba(0,0,0,0.6)');
    ctx.fillStyle = grad; ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function spawnEnemy(mode, time) {
    if(enemies.length >= MAX_ENEMIES && mode !== 'boss') return; 

    let dist = Math.max(canvas.width, canvas.height)/2 + 50;
    let ang = Math.random()*Math.PI*2;
    let ex = player.x + Math.cos(ang)*dist; let ey = player.y + Math.sin(ang)*dist; let type = mode;
    if(mode === 'random') {
        let r = Math.random();
        
        // ★ Golem Spawn Logic
        let canGolem = level >= 50;
        
        let canSplitter = time > 45; let canBat = time > 90; let canDasher = time > 120; let canShooter = time > 150; let canTank = time > 180;
        
        if(canGolem && r < 0.08) type = 'golem'; 
        else if(canTank && r < 0.15) type = 'tank'; 
        else if(canShooter && r < 0.25) type = 'shooter'; 
        else if(canDasher && r < 0.35) type = 'dasher'; 
        else if(canSplitter && r < 0.45) type = 'splitter'; 
        else if(canBat && r < 0.6) type = 'bat'; 
        else type = 'normal';
    }
    createEnemy(type, ex, ey);
}

function createEnemy(type, x, y) {
    let e = { id: Math.random(), x: x, y: y, flash: 0, type: 'mob', frozen: 0 };
    
    let hpMult = Math.pow(1.10, level - 1); 
    if(singularityMode) hpMult *= 2.0;

    if(type === 'boss') { 
        e.hp = 3000 * hpMult; e.maxHp = e.hp; e.size = 90; e.color = '#cc0000'; e.speed = 2.5 + (level * 0.02); e.ai='boss'; e.type='boss'; 
        e.hp *= (1 + bossCycleCounter * 0.3); 
        e.dmg = 50 + (level * 2);
    }
    else if(type === 'golem') {
        e.hp = 450 * hpMult; e.maxHp = e.hp; 
        e.size = 25; e.color = '#2F4F4F'; 
        e.speed = (2.0 + (level * 0.01)) * 0.3; 
        e.ai = 'normal'; e.type = 'golem';
    }
    else if(type === 'dasher') { e.hp = 25 * hpMult; e.maxHp = e.hp; e.size = 18; e.color = '#ff3333'; e.speed = 2.5 + (level * 0.02); e.ai='dasher'; e.state='chase'; }
    else if(type === 'splitter') { e.hp = 20 * hpMult; e.maxHp = e.hp; e.size = 20; e.color = '#ff3333'; e.speed = 1.2 + (level * 0.01); e.ai='splitter'; }
    else if(type === 'bat') { e.hp = 8 * hpMult; e.maxHp = e.hp; e.size = 10; e.color = '#ff3333'; e.speed = 5.0 + (level * 0.03); e.ai='bat'; }
    else if(type === 'shooter') { e.hp = 22 * hpMult; e.maxHp = e.hp; e.size = 15; e.color = '#ff3333'; e.speed = 1.8 + (level * 0.01); e.ai='shooter'; }
    else if(type === 'tank') { e.hp = 80 * hpMult; e.maxHp = e.hp; e.size = 24; e.color = '#ff3333'; e.speed = 1.0 + (level * 0.01); e.ai='tank'; }
    else if(type === 'minion') { e.hp = 8 * hpMult; e.maxHp = e.hp; e.size = 10; e.color = '#ff3333'; e.speed = 3.0 + (level * 0.02); e.ai='normal'; }
    else { e.hp = 15 * hpMult; e.maxHp = e.hp; e.size = 14; e.color = '#ff3333'; e.speed = 2.0 + (level * 0.01) + Math.random(); e.ai='normal'; }
    
    if(!e.dmg) e.dmg = 10 + Math.floor(level * 1.5);
    
    if(singularityMode) { e.color = '#000000'; e.speed *= 1.2; }

    enemies.push(e);
}

function triggerWarning() {
    let w = document.getElementById('warning-overlay'); w.style.display = 'flex';
    let count = 0; 
    let iv = setInterval(() => { Sound.play('alert'); count++; if(count >= 3) clearInterval(iv); }, 800);
}

function damageEnemy(e, dmg) {
    if(e.dead) return; 
    
    // Guardian Siege Bonus
    if(stats.siegeMode && stats.isStationary) dmg *= 2;

    let isCrit = false;
    if(Math.random() < stats.critChance || stats.deadeye) { dmg *= (stats.deadeye ? 3 : 2); isCrit = true; } 
    
    if(stats.giantSlayer && (e.type === 'boss' || e.ai === 'tank')) dmg *= 2;
    if(stats.executioner && (e.hp < e.maxHp * 0.2)) dmg = e.hp + 999; 
    if(stats.execute && (e.hp < e.maxHp * 0.3)) dmg = e.hp + 9999; 

    e.hp -= dmg; e.flash = 5; 
    if(particles.length < MAX_PARTICLES) createParticles(e.x, e.y, '#fff', 2, 2); 
    Sound.play('hit');
    if(texts.length < MAX_TEXTS) texts.push({x:e.x, y:e.y, str:Math.floor(dmg), life:20, color: isCrit?'#ff0':'#fff'});
    
    if(e.hp <= 0) {
        e.dead = true; 
        Sound.play('explode'); screenShake = e.type === 'boss' ? 20 : 3;
        if(particles.length < MAX_PARTICLES) createParticles(e.x, e.y, e.color, e.type==='boss'?50:15, 5);
        particles.push({type:'shockwave', x:e.x, y:e.y, size:10, life:15, color:'#fff'});
        
        if(stats.chainBurst) {
             Sound.play('explode', 2.0);
             let range = 100;
             let burstDmg = stats.dmg * 2;
             createParticles(e.x, e.y, '#0ff', 10, 3);
             enemies.forEach(subE => {
                 if(!subE.dead && Math.hypot(subE.x-e.x, subE.y-e.y) < range) {
                     damageEnemy(subE, burstDmg);
                 }
             });
             particles.push({type:'shockwave', x:e.x, y:e.y, size:range, life:10, color:'#0ff'});
        }

        if(stats.shrapnel) {
            for(let i=0; i<3; i++) {
                let ang = Math.random() * Math.PI * 2;
                bullets.push({
                    type:'normal', 
                    x:e.x, y:e.y, 
                    vx:Math.cos(ang)*(8+Math.random()*4), 
                    vy:Math.sin(ang)*(8+Math.random()*4), 
                    size:3, hit:[e.id], pierce:1, isMini:true,
                    life: 15
                });
            }
        }

        if(stats.necromancer) {
            bullets.push({type: 'spirit', x: e.x, y: e.y, vx: 0, vy: 0, speed: 8, size: 6, hit: [], isMini: false});
        }
        if(stats.bloodLust) { 
             player.hp = Math.min(player.maxHp, player.hp + player.maxHp * 0.01);
        }

        if(stats.lifesteal > 0) { player.hp = Math.min(player.maxHp, player.hp + stats.lifesteal); updateUI(); }

        let levelScaler = 1 + (level * 0.5); 
        if(singularityMode) levelScaler *= 2;
        let baseVal = 25 * levelScaler;

        let val = baseVal;
        if(e.type === 'boss') val = baseVal * 50;
        else if(e.ai === 'tank') val = Math.max(300, baseVal * 3);

        let orbType = { val: val, color: '#0ff', size: 4, pitch: 1.0 }; 
        if(val >= 20000) orbType = { val: val, color: '#f0f', size: 16, pitch: 0.5 }; 
        else if(val >= 6000) orbType = { val: val, color: '#f00', size: 14, pitch: 0.6 }; 
        else if(val >= 1500) orbType = { val: val, color: '#f80', size: 12, pitch: 0.7 }; 
        else if(val >= 300) orbType = { val: val, color: '#00f', size: 10, pitch: 0.8 }; 
        else if(val >= 80) orbType = { val: val, color: '#0f0', size: 8, pitch: 0.9 }; 
        
        if(e.ai === 'splitter') { createEnemy('minion', e.x+10, e.y); createEnemy('minion', e.x-10, e.y); }
        score += val; updateUI(); 
        
        // ★ FIX: Always push exp, even if maxed out (handled in update)
        expOrbs.push({x: e.x, y: e.y, size: orbType.size, val: orbType.val, color: orbType.color, pitch: orbType.pitch});

        if(Math.random() < 0.002) {
             items.push({type: 'magnet', x: e.x, y: e.y});
        }
    }
}

function addExp(v, silent) {
    if(!gameActive) return; 
    exp += v; 
    if(exp >= nextExp) { 
        exp = 0; level++; 
        nextExp = Math.floor(nextExp * 1.15) + 500; 
        Sound.play('levelup'); updateUI(); 
        
        if(level === 5) showEvo(); 
        else if(level === 40) showSecondEvo(); // ★ 2nd Evolution Trigger
        else if(level >= 20 && level % 10 === 0) showMilestone(); 
        else showUpgrade(); 
    }
    document.getElementById('xp-fill').style.width = Math.min(100, (exp/nextExp*100))+'%';
}

// ★ New Second Evolution Function
function showSecondEvo() {
    gameActive = false;
    let m = document.getElementById('menu-overlay'); let c = document.getElementById('card-area');
    c.innerHTML = ''; m.style.display = 'flex';
    document.querySelector('#menu-title').innerText = "第2次進化 (Class Evolution)";

    let evos = [];

    if(player.class === 'Assault') {
        evos = [
            {t:"💥 クラスター・ストライカー", d:"爆発特化: 着弾時に「子爆弾」が周囲に飛び散り、誘爆連鎖を引き起こす。", f:()=>{
                player.subClass = 'ClusterStriker';
                stats.clusterStriker = true;
                stats.dmg *= 1.2;
                player.color = "#ff8800";
            }},
            {t:"🌪️ バレット・ストーム", d:"弾幕特化: 攻撃中、連射速度と拡散範囲が無限に上昇する。画面を埋め尽くせ！", f:()=>{
                player.subClass = 'BulletStorm';
                stats.bulletStorm = true;
                player.color = "#0088ff";
            }}
        ];
    } else if(player.class === 'Melee') {
        evos = [
            {t:"🗡️ 御剣 (Flying Swords)", d:"遠隔斬撃: 回転刃がプレイヤーから離れ、自律して敵を追尾・切り刻む。", f:()=>{
                player.subClass = 'FlyingSwords';
                player.color = "#ff0066";
            }},
            {t:"☀️ サン・クラッシャー", d:"灼熱領域: 停止中にエネルギー充填。移動開始時に超広範囲の爆熱波を放つ。", f:()=>{
                player.subClass = 'SunCrusher';
                stats.auraRange += 50;
                player.color = "#ffd700";
            }}
        ];
    } else if(player.class === 'Sniper') {
        evos = [
            {t:"🌌 ディメンション・ウォーカー", d:"次元干渉: 弾が画面端をループする度、巨大化し威力が倍増する。", f:()=>{
                player.subClass = 'DimensionWalker';
                stats.ghostShot = true;
                stats.infinitePierce = true;
                player.color = "#88ff88";
            }},
            {t:"💎 プリズム・シューター", d:"幾何学反射: 弾が敵や壁に当たるたびに2つに分裂し、レーザー網を形成する。", f:()=>{
                player.subClass = 'PrismShooter';
                stats.prismSplit = true;
                stats.dmg *= 0.8; // Balance
                player.color = "#ff00ff";
            }}
        ];
    } else if(player.class === 'Guardian') {
        evos = [
            {t:"⚡ テスラ・エンジニア", d:"電気柵: 設置したタレット同士が「高圧電流」で接続され、触れた敵を焼き尽くす。", f:()=>{
                player.subClass = 'TeslaEngineer';
                stats.teslaGrid = true;
                stats.sentryMax = 8;
                player.color = "#00ffcc";
            }},
            {t:"🦍 アース・シェイカー", d:"重戦車: 巨大化し、歩くだけで足元に衝撃波が発生。敵を弾き飛ばし粉砕する。", f:()=>{
                player.subClass = 'EarthShaker';
                stats.isEarthShaker = true;
                player.size = 30; // Huge
                player.maxHp += 1000; player.hp += 1000;
                stats.armor += 10;
                player.color = "#885500";
            }}
        ];
    }

    evos.forEach(o => {
        let el = document.createElement('div'); el.className='card evo';
        let icon = o.t.split(' ')[0]; let title = o.t.split(' ').slice(1).join(' ');
        el.innerHTML = `<span class="icon">${icon}</span>${title}</h3><p>${o.d}</p>`;
        el.onclick = () => { 
            o.f(); 
            let nameSpan = document.getElementById('disp-class-name');
            nameSpan.innerText = `(${title})`;
            nameSpan.style.color = player.color;
            resume(); 
        };
        c.appendChild(el);
    });
}

function showMilestone() {
    gameActive = false;
    Sound.play('milestone');
    let m = document.getElementById('menu-overlay'); let c = document.getElementById('card-area');
    c.innerHTML = ''; m.style.display = 'flex';
    document.querySelector('#menu-title').innerText = "禁断の力 (Lv"+level+")";

    // Common Unique
    let pool = [
        {t:"⚡ オメガ・レーザー", d:"3秒ごとに画面を薙ぎ払う極太レーザーを発射。", f:()=>{stats.omegaLaser=true;}},
        {t:"❄️ アブソリュート・ゼロ", d:"周囲の敵を凍結させ、長時間停止させるオーラ。", f:()=>{stats.absoluteZero=true;}}, 
        {t:"💀 ネクロマンサー", d:"敵撃破時に、敵を追尾する怨霊弾を召喚する。", f:()=>{stats.necromancer=true;}},
        {t:"🩸 血の契約", d:"最大HPが1になる代わりに、攻撃力が5倍になる。", f:()=>{player.maxHp=1; player.hp=1; stats.dmg*=5;}},
        {t:"🛡️ ゴッドモード", d:"被弾時の無敵時間が3倍になる。", f:()=>{player.invincible=60;}}
    ];

    // Class Specific Pools
    if(player.class === 'Assault') {
        pool = [
            {t:"💣 爆裂弾", d:"全ての通常弾が着弾時に爆発するようになる。", f:()=>{stats.shotExplode=true;}},
            {t:"↩️ 跳弾", d:"弾が画面端で跳ね返るようになる。", f:()=>{stats.shotBounce=true;}},
            {t:"👯 ダブルトリガー", d:"50%の確率で、一度に2発の弾を発射する。", f:()=>{stats.doubleShot=true;}},
            {t:"🚀 ミサイル祭", d:"射撃時に20%の確率で追加ミサイルを発射。", f:()=>{stats.missileChance=0.2;}},
            {t:"♾️ 無限マガジン", d:"一度の発射数+3。リロード時間がゼロになる。", f:()=>{stats.infiniteMag=true;}},
            {t:"⚙️ ガトリング", d:"連射速度が限界突破し、凄まじい弾幕を張る。", f:()=>{stats.rate=Math.max(1, stats.rate-10); stats.gatling=true;}}
        ];
    } else if(player.class === 'Melee') {
        pool = [
            {t:"🦍 タイタン", d:"HP2倍、サイズ1.5倍。攻撃判定も巨大化。", f:()=>{player.maxHp*=2; player.hp*=2; player.size*=1.5; stats.titan=true;}},
            {t:"⚫ ブラックホール", d:"オーラが敵を強力に吸い寄せるようになる。", f:()=>{stats.blackHole=true;}},
            {t:"⚔️ ブレードストーム", d:"回転刃の枚数が+4枚追加される。", f:()=>{stats.bladeStorm=true;}},
            {t:"🌎 アースクエイク", d:"2秒ごとに画面全体攻撃を行い、敵を気絶させる。", f:()=>{stats.earthquake=true;}},
            {t:"🌵 スパイクリフレクト", d:"敵接触時のダメージを2倍にして反射する。", f:()=>{stats.spikeReflect=true;}},
            {t:"🧛 ブラッドラスト", d:"敵を倒すとHPが1%回復する。", f:()=>{stats.bloodLust=true;}}
        ];
    } else if(player.class === 'Sniper') {
        pool = [
            {t:"🚅 レールガン", d:"弾速2倍、サイズ2倍。全ての敵を貫通する。", f:()=>{stats.bulletSpeed*=2; stats.railgun=true; stats.infinitePierce=true;}},
            {t:"🔪 処刑人", d:"HP30%以下の敵に攻撃すると即死させる。", f:()=>{stats.execute=true;}},
            {t:"👁️ デッドアイ", d:"全ての攻撃がクリティカル(3倍ダメージ)になる。", f:()=>{stats.deadeye=true;}},
            {t:"⚡ エレクトロフェンス", d:"周囲の敵を麻痺させ、弾き飛ばす電気柵を展開。", f:()=>{stats.electroFence=true;}}, 
            {t:"💥 チェーンバースト", d:"敵を倒すと連鎖爆発が発生し、周囲を巻き込む。", f:()=>{stats.chainBurst=true;}}, 
            {t:"☄️ 天罰", d:"ランダムな位置に強力な衛星レーザーが降り注ぐ。", f:()=>{stats.orbital=true;}}
        ];
    } else if(player.class === 'Guardian') {
        pool = [
            {t:"🏗️ セントリーシステム", d:"10秒ごとに自動攻撃タレットを設置する。", f:()=>{stats.sentrySystem=true; spawnSentry();}},
            {t:"🏯 シージモード", d:"立ち止まっている間、攻撃速度とダメージが2倍。", f:()=>{stats.siegeMode=true;}},
            {t:"⚡ リアクティブアーマー", d:"ダメージを受けると、周囲に電撃カウンターを放つ。", f:()=>{stats.reactiveArmor=true;}},
            {t:"❤️ ナノマシン修復", d:"HPが30%以下になると超高速で自然回復する。", f:()=>{stats.nanoRepair=true;}},
            {t:"💣 クラスターマイン", d:"ダッシュ時に大量の地雷をばら撒く。", f:()=>{stats.clusterMine=true;}},
            {t:"🛡️ フォースフィールド", d:"定期的にダメージを完全無効化するバリアを展開。", f:()=>{stats.forceField=true;}}
        ];
    }

    pool.sort(() => Math.random() - 0.5);
    let opts = pool.slice(0, 3);

    if(level >= 100) {
        let singOpt = {t:"🌌 限界突破 (SINGULARITY)", d:"全ステータス +20%UP", f:()=>{
            stats.dmg*=1.2; stats.spd+=1; stats.rate*=0.9; stats.bulletSpeed*=1.2; player.maxHp*=1.2; player.hp=player.maxHp;
        }};
        
        let el = document.createElement('div'); el.className='card singularity';
        el.innerHTML = `<span class="icon">🌌</span><h3>${singOpt.t}</h3><p>${singOpt.d}</p>`;
        el.onclick = () => { singOpt.f(); resume(); };
        c.appendChild(el);
        opts = opts.slice(0, 2); 
    }

    opts.forEach(o => {
        let el = document.createElement('div'); el.className='card milestone';
        let icon = o.t.split(' ')[0]; let title = o.t.split(' ').slice(1).join(' ');
        el.innerHTML = `<span class="icon">${icon}</span><h3>${title}</h3><p>${o.d}</p>`;
        el.onclick = () => { o.f(); resume(); };
        c.appendChild(el);
    });
}

function showUpgrade() {
    gameActive = false;
    let m = document.getElementById('menu-overlay'); let c = document.getElementById('card-area');
    c.innerHTML = ''; m.style.display = 'flex';
    document.querySelector('#menu-title').innerText = "レベルアップ！";

    // ★ Upgrade Logic Refactored to support Rare & Percent stats
    const createOpt = (id, icon, title, val, unit, applyFunc, descGen) => {
        return { id: id, icon: icon, title: title, val: val, unit: unit, func: applyFunc, desc: descGen };
    };

    let pool = [];

    // Basic Stats (Fixed)
    pool.push(createOpt('dmg', '💪', '攻撃力', 15, '', (v)=>stats.dmg+=v, (v)=>`ダメージ +${v}`));
    pool.push(createOpt('hp', '❤️', 'HP強化', 50, '', (v)=>{player.maxHp+=v; player.hp+=v;}, (v)=>`最大HP +${v}`));
    pool.push(createOpt('spd', '👟', '移動速度', 2, '', (v)=>stats.spd+=v, (v)=>`移動速度 +${v}`));
    pool.push(createOpt('rate', '⚡', '連射速度', 3, '', (v)=>stats.rate=Math.max(2, stats.rate-v), (v)=>`連射/CD短縮`)); // Fixed behavior
    
    // Percentage Stats (Scaling)
    pool.push(createOpt('dmg_p', '💪', '攻撃倍率', 15, '%', (v)=>stats.dmg=Math.floor(stats.dmg*(1+v/100)), (v)=>`ダメージ +${v}%`));
    pool.push(createOpt('rate_p', '⏩', 'ヘイスト', 10, '%', (v)=>stats.rate=Math.max(2, stats.rate*(1-v/100)), (v)=>`攻撃速度 +${v}%`));

    // Special Stats
    pool.push(createOpt('multi', player.class==='Melee'?'⚔️':'🔫', player.class==='Melee'?'ブレード+':'マルチ/盾', 1, '', (v)=>stats.multi+=v, (v)=>player.class==='Melee'?`回転刃 +${v}`:`発射数 +${v}`));
    pool.push(createOpt('pierce', '🏹', '貫通弾', 1, '', (v)=>stats.pierce+=v, (v)=>`貫通数 +${v}`));
    pool.push(createOpt('regen', '💖', 'リジェネ', 2, '', (v)=>stats.regen+=v, (v)=>`回復 +${v}/s`));
    pool.push(createOpt('magnet', '🧲', 'マグネット', 50, '', (v)=>stats.magnet+=v, (v)=>`範囲 +${v}`));

    // Class Specifics (Fixed - No Rare Multiplier usually, but we can boost them)
    if(player.class === 'Melee' || player.class === 'Guardian') {
        pool = pool.filter(o => o.id !== 'pierce');
        pool.push(createOpt('armor', '🛡️', 'アーマー', 2, '', (v)=>stats.armor+=v, (v)=>`被ダメ -${v}`));
    }
    
    // Skill Unlocks (Fixed Logic)
    let unlocks = [
        {id:'spin', t:"⚔️ 回転刃", k:'spinBlade'}, {id:'homing', t:"🎯 ホーミング", k:'homing'},
        {id:'lightning', t:"🌩️ ライトニング", k:'lightning'}, {id:'poison', t:"☠️ 毒ガス", k:'poison'},
        {id:'chakram', t:"🥏 チャクラム", k:'chakram'}
    ];
    unlocks.forEach(u => {
        pool.push(createOpt(u.id, u.t.split(' ')[0], u.t.split(' ')[1], 1, '', (v)=>stats[u.k]+=v, (v)=>stats[u.k]===0?`${u.t.split(' ')[1]}を取得`:`${u.t.split(' ')[1]} Lv${stats[u.k]+1}`));
    });

    if(player.class === 'Assault') pool.push(createOpt('missile', '🚀', 'ミサイル', 1, '', (v)=>stats.missile+=v, (v)=>`ミサイル Lv${stats.missile+1}`));
    if(player.class === 'Sniper') pool.push(createOpt('drones', '🛰️', 'ドローン', 1, '', (v)=>stats.drones+=v, (v)=>`ドローン +${v}`));
    if(player.class === 'Melee') pool.push(createOpt('auraScale', '🛡️', 'オーラ拡大', 0.2, '', (v)=>stats.auraScale+=v, (v)=>`範囲 +${(v*100).toFixed(0)}%`));

    // Selection Logic
    let choices = [];
    let safety = 0;
    while(choices.length < 3 && safety < 100) {
        let base = pool[Math.floor(Math.random() * pool.length)];
        if(choices.some(c => c.id === base.id)) { safety++; continue; }
        
        // Clone for modifications
        let opt = { ...base }; 
        
        // ★ RARE ROLL Logic (10%)
        if(Math.random() < 0.1) {
            opt.isRare = true;
            let mult = 2; // Double effect
            if(opt.id === 'hp') mult = 3; // Triple for HP
            if(opt.id === 'multi') mult = 2; 

            opt.val = Math.floor(opt.val * mult);
            if(opt.id === 'auraScale') opt.val = parseFloat((base.val * 1.5).toFixed(1)); // Special fix float
        }

        choices.push(opt);
    }

    choices.forEach(o => {
        let el = document.createElement('div'); 
        el.className = 'card';
        if(o.isRare) el.classList.add('rare');
        
        let title = o.isRare ? `✨ ${o.title}` : o.title;
        let desc = o.desc(o.val);
        
        el.innerHTML = `<span class="icon">${o.icon}</span><h3>${title}</h3><p>${desc}</p>`;
        el.onclick = () => { o.func(o.val); resume(); };
        c.appendChild(el);
    });
}

function showEvo() {
    gameActive = false;
    let m = document.getElementById('menu-overlay'); let c = document.getElementById('card-area');
    c.innerHTML = ''; m.style.display = 'flex';
    document.querySelector('#menu-title').innerText = "クラス進化";

    // ★ GOD BUFF: スナイパー以外を魔改造レベルで強化
    let evos = [
        {t:"🔫 アサルト", d:"連射特化: マシンガン(連射・2発・貫通)解禁", f:()=>{
            player.class="Assault"; player.color="#00ffff"; 
            stats.rate=4; // マシンガン並み
            stats.dmg+=10; 
            stats.multi=1; // 最初から2発
            stats.pierce=1; // 最初から貫通
        }},
        {t:"🛡️ ヴァンガード", d:"近接: 超・広範囲 & HP+500/リジェネ+10", f:()=>{
            player.class="Melee"; player.color="#ff3333"; 
            stats.aura=true; 
            stats.auraRange=180; // 画面半分くらい覆う
            stats.spd+=4; 
            player.maxHp+=500; player.hp+=500; 
            stats.regen+=10; // 最初から超回復
        }},
        {t:"🔭 スナイパー", d:"遠距離: 💥破片 & 🔙ノックバック", f:()=>{
            player.class="Sniper"; player.color="#ffff00"; 
            stats.rate=35; stats.dmg=200; stats.pierce=2; stats.bulletSpeed=30; stats.multi=0;
            stats.drones+=1; 
            stats.shrapnel=true; 
            stats.knockback=1; 
        }},
        {t:"🧱 ガーディアン", d:"要塞: 吸引・装甲+10・タレット3倍速", f:()=>{
            player.class="Guardian"; player.color="#00ff88"; 
            stats.armor+=10; // ほぼ無敵
            player.maxHp+=1000; player.hp=player.maxHp; 
            stats.spd-=0.5; 
            stats.magnet+=200; // 動かなくていい
            stats.sentryRate=3.0; // タレットが暴れる
            stats.sentrySystem=true; spawnSentry();
        }}
    ];

    evos.forEach(o => {
        let el = document.createElement('div'); el.className='card';
        let icon = o.t.split(' ')[0]; let title = o.t.split(' ').slice(1).join(' ');
        el.innerHTML = `<span class="icon">${icon}</span><h3>${title}</h3><p>${o.d}</p>`;
        el.onclick = () => { 
            o.f(); 
            let nameSpan = document.getElementById('disp-class-name');
            nameSpan.innerText = `(${title})`;
            nameSpan.style.color = player.color;
            resume(); 
        };
        c.appendChild(el);
    });
}

function resume() {
    document.getElementById('menu-overlay').style.display = 'none';
    lastTime = performance.now(); gameActive = true; updateSkillList(); requestAnimationFrame(loop);
}

function createParticles(x,y,c,n,sizeBase) { 
    if(particles.length > MAX_PARTICLES) return; 
    for(let i=0;i<n;i++) particles.push({ x:x, y:y, vx:(Math.random()-0.5)*12, vy:(Math.random()-0.5)*12, life:10+Math.random()*5, size:(sizeBase||4)+Math.random()*2, color:c }); 
}

function updateUI() {
    document.getElementById('disp-lv').innerText = level;
    let hpPer = Math.max(0, player.hp / player.maxHp * 100);
    document.getElementById('hp-bar-fill').style.width = hpPer + '%';
    document.getElementById('disp-hp-val').innerText = Math.floor(player.hp);
    document.getElementById('disp-hp-max').innerText = Math.floor(player.maxHp);
    document.getElementById('disp-regen').innerText = stats.regen;
    document.getElementById('disp-score').innerText = score;
}

function updateSkillList() {
    let list = document.getElementById('skill-list');
    let html = "";
    if(singularityMode) html += `<div style="color:#000; text-shadow:0 0 5px #fff; font-weight:bold;">🌌 SINGULARITY MODE</div>`;

    if(stats.omegaLaser) html += `<div style="color:#f0f">⚡ OMEGA LASER</div>`;
    if(stats.absoluteZero) html += `<div style="color:#0ff">❄️ ZERO AURA</div>`;
    if(stats.titan) html += `<div style="color:#f00">🦍 TITAN</div>`;
    if(stats.gatling) html += `<div style="color:#0ff">⚙️ GATLING</div>`;
    if(stats.railgun) html += `<div style="color:#ff0">🚅 RAILGUN</div>`;
    
    // Guardian Skills
    if(stats.sentrySystem) html += `<div style="color:#0f0">🏗️ SENTRY SYS (${sentries.length})</div>`;
    if(stats.siegeMode) {
        let active = stats.isStationary ? "(ON)" : "(OFF)";
        html += `<div style="color:#0f0">🏯 SIEGE ${active}</div>`;
    }
    if(stats.reactiveArmor) html += `<div style="color:#0f0">⚡ REACTIVE ARMOR</div>`;
    if(stats.forceField) {
        let ready = stats.forceFieldCd <= 0 ? "READY" : Math.ceil(stats.forceFieldCd/60)+"s";
        html += `<div style="color:#0ff">🛡️ FORCE FIELD [${ready}]</div>`;
    }

    if(stats.chainBurst) html += `<div style="color:#0ff">💥 CHAIN BURST</div>`;
    if(stats.electroFence) html += `<div style="color:#0ff">⚡ ELECTRO FENCE</div>`;
    if(stats.armor > 0) html += `<div style="color:#8f8">🛡️ ARMOR +${stats.armor}</div>`;
    if(stats.shrapnel) html += `<div style="color:#ff0">💥 SHRAPNEL</div>`;

    if(stats.missile > 0) html += `<div style="color:#fa0">🚀 ミサイル Lv${stats.missile}</div>`;
    if(stats.drones > 0) html += `<div style="color:#ff0">🛰️ ドローン x${stats.drones}</div>`;
    if(stats.auraScale > 1) html += `<div style="color:#f00">🛡️ オーラ倍率 x${stats.auraScale.toFixed(1)}</div>`;
    if(stats.lifesteal > 0) html += `<div style="color:#f0f">🧛 吸血 +${stats.lifesteal}</div>`;
    list.innerHTML = html;
}

function gameOver() {
    gameActive = false;
    document.getElementById('final-score').innerText = score;
    document.getElementById('game-over').style.display = 'flex';
}

updateUI();
</script>
</body>
</html>
